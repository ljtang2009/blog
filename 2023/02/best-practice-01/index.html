<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/downloads/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/downloads/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/downloads/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/downloads/images/favicon/favicon.svg" color="#222">
  <meta name="google-site-verification" content="_2OctYreBeDkfTRiEHaXwB0wYaMK6F84qG97fNjM4qc">
  <meta name="msvalidate.01" content="84BDF5B17B36630CC4297E351B2B0D64">
  <meta name="baidu-site-verification" content="code-kuUu52WEwj">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.tanglijin.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":"flat","show_result":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":{"utterances":{"order":-1},"changyan":{"text":"畅言","order":0},"livere":{"text":"来必力","order":1},"valine":{"order":2},"disqus":{"order":3},"disqusjs":{"order":4},"gitalk":{"order":5},"giscus":{"order":6}},"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"HWL3YK5R6C","apiKey":"17ce0bb5e5dc71bf5e3e37006cc05b55","indexName":"blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="目录   最佳实践推荐 (01) – Node.js Best Practices  最佳实践推荐 (02) – clean-code-javascript  最佳实践推荐 (03) – 33 Concepts Every JavaScript Developer Should Know  最佳实践推荐 (04) – What the f*ck JavaScript?  最佳实践推荐 (05) –">
<meta property="og:type" content="article">
<meta property="og:title" content="最佳实践推荐 (01) -- Node.js Best Practices">
<meta property="og:url" content="https://www.tanglijin.top/2023/02/best-practice-01/index.html">
<meta property="og:site_name" content="唐李锦的空间">
<meta property="og:description" content="目录   最佳实践推荐 (01) – Node.js Best Practices  最佳实践推荐 (02) – clean-code-javascript  最佳实践推荐 (03) – 33 Concepts Every JavaScript Developer Should Know  最佳实践推荐 (04) – What the f*ck JavaScript?  最佳实践推荐 (05) –">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.tanglijin.top/2023/02/best-practice-01/banner.jpg">
<meta property="og:image" content="https://github-readme-stats.vercel.app/api/pin/?username=goldbergyoni&repo=nodebestpractices&show_owner=true">
<meta property="og:image" content="https://api.star-history.com/svg?repos=goldbergyoni/nodebestpractices&type=Date">
<meta property="article:published_time" content="2023-02-21T01:14:00.000Z">
<meta property="article:modified_time" content="2023-06-07T04:24:01.239Z">
<meta property="article:author" content="唐李锦">
<meta property="article:tag" content="Node.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tanglijin.top/2023/02/best-practice-01/banner.jpg">


<link rel="canonical" href="https://www.tanglijin.top/2023/02/best-practice-01/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.tanglijin.top/2023/02/best-practice-01/","path":"2023/02/best-practice-01/","title":"最佳实践推荐 (01) -- Node.js Best Practices"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>最佳实践推荐 (01) -- Node.js Best Practices | 唐李锦的空间</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WSZ6XMJ0XL"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-WSZ6XMJ0XL","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?85df606204b9d08c7ff41bedceef09f7"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="唐李锦的空间" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">唐李锦的空间</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">79</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">82</span></a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-Best-Practices"><span class="nav-number">1.</span> <span class="nav-text">Node.js Best Practices</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">2.</span> <span class="nav-text">学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.1.</span> <span class="nav-text">项目结构实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%BC%8F%E6%9E%84%E5%BB%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">组件式构建解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E5%B1%82%EF%BC%8C%E4%BF%9D%E6%8C%81Express%E5%9C%A8%E5%85%B6%E8%8C%83%E5%9B%B4%E5%86%85"><span class="nav-number">2.1.2.</span> <span class="nav-text">应用程序分层，保持Express在其范围内</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%85%AC%E7%94%A8%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85%E6%88%90-npm-%E5%8C%85"><span class="nav-number">2.1.3.</span> <span class="nav-text">将公用实用工具封装成 npm 包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E6%84%9F%E7%9F%A5%EF%BC%8C%E5%AE%89%E5%85%A8%EF%BC%8C%E5%88%86%E5%B1%82%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">2.1.4.</span> <span class="nav-text">使用环境感知，安全，分层的配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.2.</span> <span class="nav-text">错误处理最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E4%BD%BF%E7%94%A8-Async-Await-%E6%88%96%E8%80%85-promises"><span class="nav-number">2.2.1.</span> <span class="nav-text">对于异步的错误处理，使用 Async-Await 或者 promises</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%85%E4%BD%BF%E7%94%A8%E5%86%85%E5%BB%BA%E7%9A%84%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">仅使用内建的错误对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E6%93%8D%E4%BD%9C%E5%9E%8B%E9%94%99%E8%AF%AF%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF"><span class="nav-number">2.2.3.</span> <span class="nav-text">区分操作型错误和程序设计错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">2.2.4.</span> <span class="nav-text">集中处理错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AF%B9API%E9%94%99%E8%AF%AF%E6%96%87%E6%A1%A3%E5%8C%96"><span class="nav-number">2.2.5.</span> <span class="nav-text">使用接口管理平台对API错误文档化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E4%BA%A7%E7%94%9F%E6%97%B6%EF%BC%8C%E4%BC%98%E9%9B%85%E5%9C%B0%E9%80%80%E5%87%BA%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.2.6.</span> <span class="nav-text">特殊情况产生时，优雅地退出服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E7%86%9F%E7%9A%84logger%E6%8F%90%E9%AB%98%E9%94%99%E8%AF%AF%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">2.2.7.</span> <span class="nav-text">使用成熟的logger提高错误可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AF%E6%B5%81"><span class="nav-number">2.2.8.</span> <span class="nav-text">使用你最喜欢的测试框架测试错误流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-APM-%E4%BA%A7%E5%93%81%E5%8F%91%E7%8E%B0%E9%94%99%E8%AF%AF%E5%92%8C%E5%AE%95%E6%9C%BA%E6%97%B6%E9%97%B4"><span class="nav-number">2.2.9.</span> <span class="nav-text">使用 APM 产品发现错误和宕机时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84promise-rejections"><span class="nav-number">2.2.10.</span> <span class="nav-text">捕获未处理的promise rejections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%93%E7%94%A8%E5%BA%93%E9%AA%8C%E8%AF%81%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.11.</span> <span class="nav-text">快速报错，使用专用库验证参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-return-%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%80%BB%E6%98%AF%E4%BD%BF%E7%94%A8-await-%E6%9D%A5%E9%81%BF%E5%85%8D%E9%81%97%E6%BC%8F%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA"><span class="nav-number">2.2.12.</span> <span class="nav-text">在 return 之前，总是使用 await 来避免遗漏堆栈跟踪</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E5%BD%93%E5%9C%B0-call-%E5%92%8C-await"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">适当地 call 和 await</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E8%BF%94%E5%9B%9E-promise-%E7%9A%84%E5%87%BD%E6%95%B0%E6%A0%87%E8%AE%B0%E4%B8%BA-async"><span class="nav-number">2.2.12.2.</span> <span class="nav-text">将返回 promise 的函数标记为 async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%B0%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%BD%9C%E4%B8%BA%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%BC%A0%E9%80%92%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%B0%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%B0%81%E8%A3%85%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="nav-number">2.2.12.3.</span> <span class="nav-text">在将异步回调作为同步回调传递之前，将异步回调封装在一个虚拟异步函数中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.3.</span> <span class="nav-text">编码风格实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ESLint-%E5%92%8C-Prettier"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用 ESLint 和 Prettier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ESLint-%E6%8F%92%E4%BB%B6"><span class="nav-number">2.3.2.</span> <span class="nav-text">使用ESLint 插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%90%8C%E4%B8%80%E8%A1%8C%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7"><span class="nav-number">2.3.3.</span> <span class="nav-text">在同一行开始一个代码块的大括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%BF%98%E8%AE%B0%E5%88%86%E5%8F%B7"><span class="nav-number">2.3.4.</span> <span class="nav-text">不要忘记分号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E6%82%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.5.</span> <span class="nav-text">命名您的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.3.6.</span> <span class="nav-text">变量、常量、函数和类的命名约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8const%E4%BC%98%E4%BA%8Elet%EF%BC%8C%E5%BA%9F%E5%BC%83var"><span class="nav-number">2.3.7.</span> <span class="nav-text">使用const优于let，废弃var</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88require-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8"><span class="nav-number">2.3.8.</span> <span class="nav-text">先require, 而不是在方法内部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#require-%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.9.</span> <span class="nav-text">require 文件夹，而不是文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-x3D-x3D-x3D-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.3.10.</span> <span class="nav-text">使用 &#x3D;&#x3D;&#x3D; 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Async-Await-%E9%81%BF%E5%85%8D%E5%9B%9E%E8%B0%83"><span class="nav-number">2.3.11.</span> <span class="nav-text">使用 Async Await, 避免回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-x3D-gt-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.12.</span> <span class="nav-text">使用 (&#x3D;&gt;) 箭头函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%BB%E4%BD%93%E7%9A%84%E8%B4%A8%E9%87%8F%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.4.</span> <span class="nav-text">测试和总体的质量实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%B3%E5%B0%91%EF%BC%8C%E7%BC%96%E5%86%99API%EF%BC%88%E7%BB%84%E4%BB%B6%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="nav-number">2.4.1.</span> <span class="nav-text">至少，编写API（组件）测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AAlinter%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用一个linter检测代码问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">2.4.3.</span> <span class="nav-text">单元测试三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-AAA-%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">2.4.4.</span> <span class="nav-text">用 AAA 模式构建单元测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E6%88%96%E5%85%A8%E5%B1%80%E6%BA%90%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.5.</span> <span class="nav-text">避免全局设置或全局源数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%B8%B8%E6%A3%80%E6%9F%A5%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">2.4.6.</span> <span class="nav-text">经常检查易受攻击的依赖项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E6%B5%8B%E8%AF%95%E5%81%9A%E6%A0%87%E8%AE%B0"><span class="nav-number">2.4.7.</span> <span class="nav-text">给测试做标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%82%A8%E7%9A%84%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-number">2.4.8.</span> <span class="nav-text">检查您的测试覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-number">2.4.9.</span> <span class="nav-text">检查过期的依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E5%81%9A%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95"><span class="nav-number">2.4.10.</span> <span class="nav-text">使用类生成环境做端到端测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E5%B9%B6%E9%87%8D%E6%9E%84"><span class="nav-number">2.4.11.</span> <span class="nav-text">使用静态分析工具分析代码并重构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%94%E7%BB%86%E6%8C%91%E9%80%89-CI-%E5%B9%B3%E5%8F%B0"><span class="nav-number">2.4.12.</span> <span class="nav-text">仔细挑选 CI 平台</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%8B%AC%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.4.13.</span> <span class="nav-text">单独测试中间件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E7%BA%BF%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.5.</span> <span class="nav-text">上线实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7"><span class="nav-number">2.5.1.</span> <span class="nav-text">监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%97%A5%E5%BF%97%E4%BD%BF%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%98%E5%BE%97%E6%B8%85%E6%99%B0"><span class="nav-number">2.5.2.</span> <span class="nav-text">使用智能日志使你的应用程序变得清晰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E4%BB%BB%E4%BD%95%E5%8F%AF%E8%83%BD%E7%9A%84-%E4%BE%8B%E5%A6%82%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9%EF%BC%8Cgzip-%E5%88%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">2.5.3.</span> <span class="nav-text">委托任何可能的 (例如静态内容，gzip) 到反向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC"><span class="nav-number">2.5.4.</span> <span class="nav-text">锁定依赖版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E5%92%8C%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.5.5.</span> <span class="nav-text">保护和重启失败进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8CPU%E5%A4%9A%E6%A0%B8"><span class="nav-number">2.5.6.</span> <span class="nav-text">利用CPU多核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%B4%E6%8A%A4%E7%AB%AF%E7%82%B9"><span class="nav-number">2.5.7.</span> <span class="nav-text">创建维护端点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8APM%E4%BA%A7%E5%93%81%E7%A1%AE%E4%BF%9D%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"><span class="nav-number">2.5.8.</span> <span class="nav-text">使用APM产品确保用户体验</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E4%BB%A3%E7%A0%81"><span class="nav-number">2.5.9.</span> <span class="nav-text">为生产环境准备代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E5%92%8C%E9%98%B2%E8%8C%83%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">2.5.10.</span> <span class="nav-text">测量和防范内存使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8node%E5%A4%96%E5%A4%84%E7%90%86%E6%82%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%B5%84%E4%BA%A7"><span class="nav-number">2.5.11.</span> <span class="nav-text">在node外处理您的前端资产</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8C%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-number">2.5.12.</span> <span class="nav-text">保持服务器无状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9C%89%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">2.5.13.</span> <span class="nav-text">使用工具自动检测有漏洞的依赖项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%80%E4%B8%AAlog%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E6%98%8E-%E2%80%98TransactionId%E2%80%99"><span class="nav-number">2.5.14.</span> <span class="nav-text">在每一个log语句中指明 ‘TransactionId’</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-NODE-ENV-x3D-production"><span class="nav-number">2.5.15.</span> <span class="nav-text">配置环境变量 NODE_ENV &#x3D; production</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E3%80%81%E5%8E%9F%E5%AD%90%E5%8C%96%E5%92%8C%E9%9B%B6%E5%81%9C%E6%9C%BA%E6%97%B6%E9%97%B4%E9%83%A8%E7%BD%B2"><span class="nav-number">2.5.16.</span> <span class="nav-text">设计自动化、原子化和零停机时间部署</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Node-js-%E7%9A%84-LTS-%E7%89%88%E6%9C%AC"><span class="nav-number">2.5.17.</span> <span class="nav-text">使用 Node.js 的 LTS 版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%A6%81%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98"><span class="nav-number">2.5.18.</span> <span class="nav-text">应用程序不要处理日志保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8-npm-ci-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="nav-number">2.5.19.</span> <span class="nav-text">生产模式下使用 npm ci 安装依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.6.</span> <span class="nav-text">安全最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E6%8A%A4linter%E5%AE%89%E5%85%A8%E5%87%86%E5%88%99"><span class="nav-number">2.6.1.</span> <span class="nav-text">拥护linter安全准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%88%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82"><span class="nav-number">2.6.2.</span> <span class="nav-text">使用负载均衡或中间件处理并发请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E6%9C%BA%E5%AF%86%E4%BF%A1%E6%81%AF%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8A%BD%E7%A6%BB%E5%87%BA%E6%9D%A5%EF%BC%8C%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E5%8C%85%E5%AF%B9%E5%85%B6%E5%8A%A0%E5%AF%86"><span class="nav-number">2.6.3.</span> <span class="nav-text">把机密信息从配置文件中抽离出来，或者使用包对其加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ORM-x2F-ODM-%E5%BA%93%E9%98%B2%E6%AD%A2%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="nav-number">2.6.4.</span> <span class="nav-text">使用 ORM&#x2F;ODM 库防止查询注入漏洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%9B%86%E5%90%88"><span class="nav-number">2.6.5.</span> <span class="nav-text">通用安全最佳实践集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-HTTPS-%E5%8A%A0%E5%AF%86%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">使用 HTTPS 加密连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%9C%B0%E6%AF%94%E8%BE%83%E7%A7%98%E5%AF%86%E5%80%BC%E5%92%8C%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">安全地比较秘密值和哈希值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Node-js%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.6.5.3.</span> <span class="nav-text">使用Node.js生成随机字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OWASP-%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.6.5.4.</span> <span class="nav-text">OWASP 建议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E6%95%B4-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BB%A5%E5%8A%A0%E5%BC%BA%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.6.6.</span> <span class="nav-text">调整 HTTP 响应头以加强安全性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%B8%B8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="nav-number">2.6.7.</span> <span class="nav-text">经常自动检查易受攻击的依赖库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81"><span class="nav-number">2.6.8.</span> <span class="nav-text">保护用户的密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E8%BE%93%E5%87%BA"><span class="nav-number">2.6.9.</span> <span class="nav-text">转义输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BC%A0%E5%85%A5%E7%9A%84JSON-schemas"><span class="nav-number">2.6.10.</span> <span class="nav-text">验证传入的JSON schemas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84JWT"><span class="nav-number">2.6.11.</span> <span class="nav-text">支持黑名单的JWT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3"><span class="nav-number">2.6.12.</span> <span class="nav-text">限制登录请求，防止暴力破解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E8%BF%90%E8%A1%8CNode-js"><span class="nav-number">2.6.13.</span> <span class="nav-text">使用非root用户运行Node.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%88%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E5%88%B6%E8%B4%9F%E8%BD%BD%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.6.14.</span> <span class="nav-text">使用反向代理或中间件限制负载大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8DJS-eval%E8%AF%AD%E6%B3%95"><span class="nav-number">2.6.15.</span> <span class="nav-text">避免JS eval语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8FRegEx%E8%AE%A9Node-js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%87%E8%BD%BD%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.16.</span> <span class="nav-text">防止恶意RegEx让Node.js的单线程过载执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="nav-number">2.6.17.</span> <span class="nav-text">避免使用变量加载模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%B2%99%E7%AE%B1%E4%B8%AD%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">2.6.18.</span> <span class="nav-text">在沙箱中运行不安全代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%97%B6%E8%A6%81%E8%B0%A8%E6%85%8E"><span class="nav-number">2.6.19.</span> <span class="nav-text">处理子进程时要谨慎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%94%99%E8%AF%AF%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-number">2.6.20.</span> <span class="nav-text">隐藏客户端的错误详细信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9npm%E6%88%96Yarn%EF%BC%8C%E9%85%8D%E7%BD%AE2FA"><span class="nav-number">2.6.21.</span> <span class="nav-text">对npm或Yarn，配置2FA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9session%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.6.22.</span> <span class="nav-text">修改session中间件设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%98%BE%E5%BC%8F%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E5%BA%94%E5%B4%A9%E6%BA%83%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%BB%A5%E9%81%BF%E5%85%8DDOS%E6%94%BB%E5%87%BB"><span class="nav-number">2.6.23.</span> <span class="nav-text">通过显式设置进程应崩溃的情况，以避免DOS攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.6.24.</span> <span class="nav-text">避免不安全的重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%B0%86%E6%9C%BA%E5%AF%86%E4%BF%A1%E6%81%AF%E5%8F%91%E5%B8%83%E5%88%B0NPM%E4%BB%93%E5%BA%93"><span class="nav-number">2.6.25.</span> <span class="nav-text">避免将机密信息发布到NPM仓库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.7.</span> <span class="nav-text">Docker 最佳实践</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="唐李锦"
      src="/downloads/images/avatar.png">
  <p class="site-author-name" itemprop="name">唐李锦</p>
  <div class="site-description" itemprop="description">我的名字叫唐李锦，这是我的空间。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">79</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="/downloads/images/wechat.png" title="微信 → &#x2F;downloads&#x2F;images&#x2F;wechat.png" rel="noopener me"><i class="fa fa-comments fa-fw"></i>微信</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ljtang2009" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljtang2009" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ho_ho_gl@hotmail.com" title="E-Mail → mailto:ho_ho_gl@hotmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.tanglijin.top/2023/02/best-practice-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/downloads/images/avatar.png">
      <meta itemprop="name" content="唐李锦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐李锦的空间">
      <meta itemprop="description" content="我的名字叫唐李锦，这是我的空间。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="最佳实践推荐 (01) -- Node.js Best Practices | 唐李锦的空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          最佳实践推荐 (01) -- Node.js Best Practices
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-21 09:14:00" itemprop="dateCreated datePublished" datetime="2023-02-21T09:14:00+08:00">2023-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-07 12:24:01" itemprop="dateModified" datetime="2023-06-07T12:24:01+08:00">2023-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%8E%A8%E8%8D%90/" itemprop="url" rel="index"><span itemprop="name">最佳实践推荐</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><details class="note info no-icon"><summary><p>目录</p>
</summary>
<ul>
<li><p><a href="/2023/02/best-practice-01/" title="最佳实践推荐 (01) -- Node.js Best Practices">最佳实践推荐 (01) – Node.js Best Practices</a></p>
</li>
<li><p><a href="/2023/02/best-practice-02/" title="最佳实践推荐 (02) -- clean-code-javascript">最佳实践推荐 (02) – clean-code-javascript</a></p>
</li>
<li><p><a href="/2023/02/best-practice-03/" title="最佳实践推荐 (03) -- 33 Concepts Every JavaScript Developer Should Know">最佳实践推荐 (03) – 33 Concepts Every JavaScript Developer Should Know</a></p>
</li>
<li><p><a href="/2023/02/best-practice-04/" title="最佳实践推荐 (04) -- What the f*ck JavaScript?">最佳实践推荐 (04) – What the f*ck JavaScript?</a></p>
</li>
<li><p><a href="/2023/02/best-practice-05/" title="最佳实践推荐 (05) -- Javascript Best testing practice">最佳实践推荐 (05) – Javascript Best testing practice</a></p>
</li>
<li><p><a href="/2023/02/best-practice-06/" title="最佳实践推荐 (06) -- Functional Programming Jargon 函数式编程术语">最佳实践推荐 (06) – Functional Programming Jargon 函数式编程术语</a></p>
</li>
<li><p><a href="/2023/02/best-practice-07/" title="最佳实践推荐 (07) -- Node.js 调试指南">最佳实践推荐 (07) – Node.js 调试指南</a></p>
</li>
</ul>

</details>


<p><img src="/2023/02/best-practice-01/banner.jpg" alt="Node.js Best Practices"></p>
<h2 id="Node-js-Best-Practices"><a href="#Node-js-Best-Practices" class="headerlink" title="Node.js Best Practices"></a>Node.js Best Practices</h2><p>Node.js 最佳实践。很多关于Node.js的优秀文章。</p>
<span id="more"></span>

<p style="text-align: center;"><a href="https://github.com/goldbergyoni/nodebestpractices" target="_blank">官网地址</a></p><img src="https://github-readme-stats.vercel.app/api/pin/?username=goldbergyoni&repo=nodebestpractices&show_owner=true" loading="lazy" /><img src="https://api.star-history.com/svg?repos=goldbergyoni/nodebestpractices&type=Date" loading="lazy" />

<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><h3 id="项目结构实践"><a href="#项目结构实践" class="headerlink" title="项目结构实践"></a>项目结构实践</h3><h4 id="组件式构建解决方案"><a href="#组件式构建解决方案" class="headerlink" title="组件式构建解决方案"></a>组件式构建解决方案</h4><p>最终的解决方案是开发小型软件：将整个堆栈划分为独立的组件，这些组件不与其他组件共享文件，每个组件由很少的文件构成（例如API、服务、数据访问、测试等），因此很容易理解它。</p>
<mark class="label success">推荐</mark>: 通过独立组件构建解决方案

<pre><code>src
└─components
    ├─orders
    ├─products
    └─users
      └─index.js
      └─usersAPI.js
      └─usersDAL.js
</code></pre>
<mark class="label danger">避免</mark>: 按技术角色对文件进行分组

<pre><code>src
└─controllers
└─modules
└─models
  └─users.js
  └─orders.js
  └─products.js
</code></pre>
<h4 id="应用程序分层，保持Express在其范围内"><a href="#应用程序分层，保持Express在其范围内" class="headerlink" title="应用程序分层，保持Express在其范围内"></a>应用程序分层，保持Express在其范围内</h4><mark class="label success">推荐</mark>: 创建并传递定制的上下问对象。

<figure class="highlight javascript"><figcaption><span>usersAPI.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, (req, res, next) = &#123;</span><br><span class="line">  usersDBAccess.<span class="title function_">getByID</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">userID</span>: req.<span class="property">user</span>.<span class="property">id</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>usersDAL.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UsersDAL</span> &#123;</span><br><span class="line">  <span class="title function_">getByID</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">otherFunction</span>(config.<span class="property">userID</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>: Express 对象（例如 request, response）传递到业务逻辑层。

<p>这将使得整个系统过渡依赖 Express，并且不可单元测试。</p>
<figure class="highlight javascript"><figcaption><span>usersAPI.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, (req, res, next) = &#123;</span><br><span class="line">  usersDBAccess.<span class="title function_">getByID</span>(req);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>usersDAL.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UsersDAL</span> &#123;</span><br><span class="line">  <span class="title function_">getByID</span>(<span class="params">req</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">otherFunction</span>(req);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将公用实用工具封装成-npm-包"><a href="#将公用实用工具封装成-npm-包" class="headerlink" title="将公用实用工具封装成 npm 包"></a>将公用实用工具封装成 npm 包</h4><p>无需公开分享 <a target="_blank" rel="noopener" href="https://docs.npmjs.com/private-modules/intro">私人模块</a>, <a target="_blank" rel="noopener" href="https://npme.npmjs.com/docs/tutorials/npm-enterprise-with-nexus.html">私人注册表</a> 或 <a target="_blank" rel="noopener" href="https://medium.com/@arnaudrinquin/build-modular-application-with-npm-local-modules-dfc5ff047bcc">本地 npm 包</a>。</p>
<h4 id="使用环境感知，安全，分层的配置"><a href="#使用环境感知，安全，分层的配置" class="headerlink" title="使用环境感知，安全，分层的配置"></a>使用环境感知，安全，分层的配置</h4><p>配置分环境（例如测试环境，生成环境）。<mark class="label danger">避免</mark>存储像密码数据这样的敏感信息。<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/dotenv">dotenv</a>, <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/config">config</a>可选用．</p>
<h3 id="错误处理最佳实践"><a href="#错误处理最佳实践" class="headerlink" title="错误处理最佳实践"></a>错误处理最佳实践</h3><h4 id="对于异步的错误处理，使用-Async-Await-或者-promises"><a href="#对于异步的错误处理，使用-Async-Await-或者-promises" class="headerlink" title="对于异步的错误处理，使用 Async-Await 或者 promises"></a>对于异步的错误处理，使用 Async-Await 或者 promises</h4><p>使用 promises 捕获错误:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doWork</span>()</span><br><span class="line">  .<span class="title function_">then</span>(doWork)</span><br><span class="line">  .<span class="title function_">then</span>(doOtherWork)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> doWork)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(verify);</span><br></pre></td></tr></table></figure>

<p>使用 async&#x2F;await 捕获错误:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">executeAsyncTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> valueA = <span class="keyword">await</span> <span class="title function_">functionA</span>();</span><br><span class="line">    <span class="keyword">const</span> valueB = <span class="keyword">await</span> <span class="title function_">functionB</span>(valueA);</span><br><span class="line">    <span class="keyword">const</span> valueC = <span class="keyword">await</span> <span class="title function_">functionC</span>(valueB);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">functionD</span>(valueC);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    logger.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">alwaysExecuteThisFunction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="仅使用内建的错误对象"><a href="#仅使用内建的错误对象" class="headerlink" title="仅使用内建的错误对象"></a>仅使用内建的错误对象</h4><p>使用Node.js的内置错误对象有助于在你的代码和第三方库之间保持一致性，它还保留了重要信息，比如StackTrace。当引发异常时，给异常附加上下文属性（如错误名称和相关的HTTP错误代码）通常是一个好的习惯。</p>
<mark class="label success">推荐</mark>:
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从典型函数抛出错误, 无论是同步还是异步</span></span><br><span class="line"><span class="keyword">if</span>(!productToAdd)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;How can I add new product when no value provided?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从EventEmitter抛出错误</span></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">myEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;whoops!&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//从promise抛出错误</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title class_">Return</span> <span class="variable constant_">DAL</span>.<span class="title function_">getProduct</span>(productToAdd.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">existingProduct</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(existingProduct != <span class="literal">null</span>)</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Why fooling us and trying to add an existing product?&quot;</span>));</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抛出字符串错误缺少任何stack trace信息和其他重要属性</span></span><br><span class="line"><span class="keyword">if</span>(!productToAdd)</span><br><span class="line">    <span class="keyword">throw</span> (<span class="string">&quot;How can I add new product when no value provided?&quot;</span>);</span><br></pre></td></tr></table></figure>

<mark class="label success">更推荐</mark>:
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从node错误派生的集中错误对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appError</span>(<span class="params">name, httpCode, description, isOperational</span>) &#123;</span><br><span class="line">    <span class="title class_">Error</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="comment">//...在这赋值其它属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">appError.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Error</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">appError.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = appError;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">appError</span> = appError;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端抛出一个错误</span></span><br><span class="line"><span class="keyword">if</span>(user == <span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">appError</span>(commonErrors.<span class="property">resourceNotFound</span>, commonHTTPErrors.<span class="property">notFound</span>, <span class="string">&quot;further explanation&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h4 id="区分操作型错误和程序设计错误"><a href="#区分操作型错误和程序设计错误" class="headerlink" title="区分操作型错误和程序设计错误"></a>区分操作型错误和程序设计错误</h4><p>区分以下两种错误类型将最大限度地减少应用程序停机时间并帮助避免出现荒唐的错误: 操作型错误指的是您了解发生了什么情况及其影响的情形 – 例如, 由于连接问题而导致对某些 HTTP 服务的查询失败问题。另一方面, 程序型错误指的是您不知道原因, 有时是错误不知道来自何处的情况 – 可能是一些代码试图读取未定义的值或 DB 连接池内存泄漏。操作型错误相对容易处理 – 通常记录错误就足够了。当程序型错误出现，事情变得难以应付, 应用程序可能处于不一致状态, 你可以做的，没有什么比优雅的重新启动更好了。</p>
<h4 id="集中处理错误"><a href="#集中处理错误" class="headerlink" title="集中处理错误"></a>集中处理错误</h4><p>一个典型的错误处理流程可能是：一些模块抛出一个错误 -&gt; API路由器捕获错误 -&gt; 它传播错误给负责捕获错误的中间件（如Express，KOA）-&gt; 集中式错误处理程序被调用 -&gt; 中间件正在被告之这个错误是否是一个不可信的错误（不是操作型错误），这样可以优雅的重新启动应用程序。</p>
<p>一个典型错误流:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAL层, 在这里我们不处理错误</span></span><br><span class="line"><span class="variable constant_">DB</span>.<span class="title function_">addDocument</span>(newCustomer, <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Great error explanation comes here&quot;</span>, other useful parameters)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//API路由代码, 我们同时捕获异步和同步错误，并转到中间件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    customerService.<span class="title function_">addNew</span>(req.<span class="property">body</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">        res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(result);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(error)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">next</span>(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件，我们委托集中式错误处理程序处理错误</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">    errorHandler.<span class="title function_">handleError</span>(err).<span class="title function_">then</span>(<span class="function">(<span class="params">isOperationalError</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOperationalError)</span><br><span class="line">            <span class="title function_">next</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在一个专门的对象里面处理错误:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">handler</span> = <span class="keyword">new</span> <span class="title function_">errorHandler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">errorHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleError</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> logger.<span class="title function_">logError</span>(err).<span class="title function_">then</span>(sendMailToAdminIfCritical).<span class="title function_">then</span>(saveInOpsQueueIfCritical).<span class="title function_">then</span>(determineIfOperationalError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用接口管理平台对API错误文档化"><a href="#使用接口管理平台对API错误文档化" class="headerlink" title="使用接口管理平台对API错误文档化"></a>使用接口管理平台对API错误文档化</h4><p>REST API使用HTTP代码返回结果, API用户不仅绝对需要了解API schema, 而且还要注意潜在错误 – 调用方可能会捕获错误并巧妙地处理它。例如, 您的api文档可能提前指出, 当客户名称已经存在时, HTTP状态409将返回 (假设api注册新用户), 因此调用方可以相应地呈现给定情况下的最佳UX。<br>工具参考: <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/925370#slide-2">https://developer.aliyun.com/article/925370#slide-2</a></p>
<h4 id="特殊情况产生时，优雅地退出服务"><a href="#特殊情况产生时，优雅地退出服务" class="headerlink" title="特殊情况产生时，优雅地退出服务"></a>特殊情况产生时，优雅地退出服务</h4><p>杀进程，使用“重启”的工具（像Forever，PM2，等等）重新开始。</p>
<p>决定是否退出:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming developers mark known operational errors with error.isOperational=true, read best practice #3</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">  errorManagement.<span class="property">handler</span>.<span class="title function_">handleError</span>(error);</span><br><span class="line">  <span class="keyword">if</span>(!errorManagement.<span class="property">handler</span>.<span class="title function_">isTrustedError</span>(error))</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// centralized error object that derives from Node’s Error</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  public readonly <span class="attr">isOperational</span>: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">description: string, isOperational: boolean</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(description);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="keyword">new</span>.<span class="property">target</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// restore prototype chain</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOperational</span> = isOperational;</span><br><span class="line">    <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// centralized error handler encapsulates error-handling related logic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line">  public <span class="keyword">async</span> <span class="title function_">handleError</span>(<span class="attr">err</span>: <span class="title class_">Error</span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> logger.<span class="title function_">logError</span>(err);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sendMailToAdminIfCritical</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">saveInOpsQueueIfCritical</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">determineIfOperationalError</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public <span class="title function_">isTrustedError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">AppError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> error.<span class="property">isOperational</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handler = <span class="keyword">new</span> <span class="title class_">ErrorHandler</span>();</span><br></pre></td></tr></table></figure>

<h4 id="使用成熟的logger提高错误可见性"><a href="#使用成熟的logger提高错误可见性" class="headerlink" title="使用成熟的logger提高错误可见性"></a>使用成熟的logger提高错误可见性</h4><p>一套实践和工具将有助于更快速地解释错误 – (1)使用不同的级别（debug, info, error）频繁地log；(2)在记录日志时, 以 JSON 对象的方式提供上下文信息, 请参见下面的示例；(3)使用日志查询API(在大多数logger中内置)或日志查看程序软件监视和筛选日志；(4)使用操作智能工具(如 Splunk)为操作团队公开和管理日志语句。<br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/pino">Pino</a>(专注于性能的新库), <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/winston">Winston</a>(非常流行).</p>
<h4 id="使用你最喜欢的测试框架测试错误流"><a href="#使用你最喜欢的测试框架测试错误流" class="headerlink" title="使用你最喜欢的测试框架测试错误流"></a>使用你最喜欢的测试框架测试错误流</h4><h4 id="使用-APM-产品发现错误和宕机时间"><a href="#使用-APM-产品发现错误和宕机时间" class="headerlink" title="使用 APM 产品发现错误和宕机时间"></a>使用 APM 产品发现错误和宕机时间</h4><p>异常 !&#x3D; 错误。传统的错误处理假定存在异常，但应用程序错误可能以代码路径慢，API停机，缺少计算资源等形式出现。因为APM产品允许使用最小的设置来先前一步地检测各种各样 “深埋” 的问题，这是运用它们方便的地方。APM产品的常见功能包括: 当HTTP API返回错误时报警, 在API响应时间低于某个阈值时能被检测, 觉察到‘code smells’，监视服务器资源，包含IT度量的操作型智能仪表板以及其他许多有用的功能。</p>
<h4 id="捕获未处理的promise-rejections"><a href="#捕获未处理的promise-rejections" class="headerlink" title="捕获未处理的promise rejections"></a>捕获未处理的promise rejections</h4><p>使用一个优雅的回调并订阅到process.on（’unhandledrejection’，callback）是高度推荐的 – 这将确保任何promise错误，如果不是本地处理，将在这处理。</p>
<p>这些错误将不会得到任何错误处理程序捕获（除了 unhandledrejection）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DAL</span>.<span class="title function_">getUserById</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">johnSnow</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//this error will just vanish</span></span><br><span class="line">  <span class="keyword">if</span>(johnSnow.<span class="property">isAlive</span> == <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;ahhhh&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>捕获 unresolved 和 rejected 的 promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">reason, p</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//我刚刚捕获了一个未处理的promise rejection, 因为我们已经有了对于未处理错误的后备的处理机制（见下面）, 直接抛出，让它来处理</span></span><br><span class="line">  <span class="keyword">throw</span> reason;</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//我刚收到一个从未被处理的错误，现在处理它，并决定是否需要重启应用</span></span><br><span class="line">  errorManagement.<span class="property">handler</span>.<span class="title function_">handleError</span>(error);</span><br><span class="line">  <span class="keyword">if</span> (!errorManagement.<span class="property">handler</span>.<span class="title function_">isTrustedError</span>(error))</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="快速报错，使用专用库验证参数"><a href="#快速报错，使用专用库验证参数" class="headerlink" title="快速报错，使用专用库验证参数"></a>快速报错，使用专用库验证参数</h4><p>由于对显式编程和防御性编程是件恼人的事情（比如考虑验证分层的JSON对象，它包含像email和日期这样的字段），我们倾向于避免做这样的事情 – 像Joi这样的库和验证器轻而易举的处理这个乏味的任务。</p>
<p>使用‘Joi’验证复杂的JSON输入:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memberSchema = <span class="title class_">Joi</span>.<span class="title function_">object</span>().<span class="title function_">keys</span>(&#123;</span><br><span class="line"> <span class="attr">password</span>: <span class="title class_">Joi</span>.<span class="title function_">string</span>().<span class="title function_">regex</span>(<span class="regexp">/^[a-zA-Z0-9]&#123;3,30&#125;$/</span>),</span><br><span class="line"> <span class="attr">birthyear</span>: <span class="title class_">Joi</span>.<span class="title function_">number</span>().<span class="title function_">integer</span>().<span class="title function_">min</span>(<span class="number">1900</span>).<span class="title function_">max</span>(<span class="number">2013</span>),</span><br><span class="line"> <span class="attr">email</span>: <span class="title class_">Joi</span>.<span class="title function_">string</span>().<span class="title function_">email</span>()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addNewMember</span>(<span class="params">newMember</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//assertions come first</span></span><br><span class="line"> <span class="title class_">Joi</span>.<span class="title function_">assert</span>(newMember, memberSchema); <span class="comment">//throws if validation fails</span></span><br><span class="line"> <span class="comment">//other logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在-return-之前，总是使用-await-来避免遗漏堆栈跟踪"><a href="#在-return-之前，总是使用-await-来避免遗漏堆栈跟踪" class="headerlink" title="在 return 之前，总是使用 await 来避免遗漏堆栈跟踪"></a>在 return 之前，总是使用 await 来避免遗漏堆栈跟踪</h4><p>如果一个异步函数没有等待就返回一个promise(例如调用其他异步函数)，如果发生错误，那么调用方函数将不会出现在堆栈跟踪中。</p>
<p>这将使诊断错误的人只得到部分信息。</p>
<h5 id="适当地-call-和-await"><a href="#适当地-call-和-await" class="headerlink" title="适当地 call 和 await"></a>适当地 call 和 await</h5><mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwAsync</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span> <span class="comment">// 至少需要 await 一些东西才能真正实现异步</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">returnWithAwait</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">throwAsync</span>(<span class="string">&#x27;with all frames present&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 will have returnWithAwait in the stacktrace</span></span><br><span class="line"><span class="title function_">returnWithAwait</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: with all frames present</span><br><span class="line">    at throwAsync ([...])</span><br><span class="line">    at async returnWithAwait ([...])</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwAsync</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span> <span class="comment">// 至少需要 await 一些东西才能真正实现异步</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">returnWithoutAwait</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">throwAsync</span>(<span class="string">&#x27;missing returnWithoutAwait in the stacktrace&#x27;</span>) <span class="comment">// 没有等待 await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👎 will NOT have returnWithoutAwait in the stacktrace</span></span><br><span class="line"><span class="title function_">returnWithoutAwait</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: missing returnWithoutAwait in the stacktrace</span><br><span class="line">    at throwAsync ([...])</span><br></pre></td></tr></table></figure>

<h5 id="将返回-promise-的函数标记为-async"><a href="#将返回-promise-的函数标记为-async" class="headerlink" title="将返回 promise 的函数标记为 async"></a>将返回 promise 的函数标记为 async</h5><mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwAsync</span> () &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span> <span class="comment">// 至少需要 await 一些东西才能真正实现异步</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;with all frames present&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">changedFromSyncToAsyncFn</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">throwAsync</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFn</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">changedFromSyncToAsyncFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 now changedFromSyncToAsyncFn would present in the stacktrace</span></span><br><span class="line"><span class="title function_">asyncFn</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: with all frames present</span><br><span class="line">    at throwAsync ([...])</span><br><span class="line">    at changedFromSyncToAsyncFn ([...])</span><br><span class="line">    at async asyncFn ([...])</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">throwAsync</span> () &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;missing syncFn in the stacktrace&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">syncFn</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">throwAsync</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFn</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">syncFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👎 syncFn would be missing in the stacktrace because it returns a promise while been sync</span></span><br><span class="line"><span class="title function_">asyncFn</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: missing syncFn in the stacktrace</span><br><span class="line">    at throwAsync ([...])</span><br><span class="line">    at async asyncFn ([...])</span><br></pre></td></tr></table></figure>

<h5 id="在将异步回调作为同步回调传递之前，将异步回调封装在一个虚拟异步函数中"><a href="#在将异步回调作为同步回调传递之前，将异步回调封装在一个虚拟异步函数中" class="headerlink" title="在将异步回调作为同步回调传递之前，将异步回调封装在一个虚拟异步函数中"></a>在将异步回调作为同步回调传递之前，将异步回调封装在一个虚拟异步函数中</h5><mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span> (id) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!id) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;with all frames present&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userIds = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👍 now the line below is in the stacktrace</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(userIds.<span class="title function_">map</span>(<span class="keyword">async</span> id =&gt; <span class="keyword">await</span> <span class="title function_">getUser</span>(id))).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: with all frames present</span><br><span class="line">    at getUser ([...])</span><br><span class="line">    at async ([...])</span><br><span class="line">    at async Promise.all (index 2)</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span> (id) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!id) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;stacktrace is missing the place where getUser has been called&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userIds = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 👎 the stacktrace would include getUser function but would give no clue on where it has been called</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(userIds.<span class="title function_">map</span>(getUser)).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: stacktrace is missing the place where getUser has been called</span><br><span class="line">    at getUser ([...])</span><br><span class="line">    at async Promise.all (index 2)</span><br></pre></td></tr></table></figure>

<h3 id="编码风格实践"><a href="#编码风格实践" class="headerlink" title="编码风格实践"></a>编码风格实践</h3><h4 id="使用-ESLint-和-Prettier"><a href="#使用-ESLint-和-Prettier" class="headerlink" title="使用 ESLint 和 Prettier"></a>使用 ESLint 和 Prettier</h4><p><a target="_blank" rel="noopener" href="https://eslint.org/">ESLint</a>检查可能的代码错误和修复代码样式，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/prettier">prettier</a>和<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/js-beautify">beautify</a>在格式化修复上功能强大，可以和ESlint结合起来使用。</p>
<h4 id="使用ESLint-插件"><a href="#使用ESLint-插件" class="headerlink" title="使用ESLint 插件"></a>使用ESLint 插件</h4><p>除了仅仅涉及 vanilla JS 的 ESLint 标准规则，添加 Node 相关的插件，比如<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-node">eslint-plugin-node</a>, <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-mocha">eslint-plugin-mocha</a> and <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-security">eslint-plugin-node-security</a>。</p>
<h4 id="在同一行开始一个代码块的大括号"><a href="#在同一行开始一个代码块的大括号" class="headerlink" title="在同一行开始一个代码块的大括号"></a>在同一行开始一个代码块的大括号</h4><mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要忘记分号"><a href="#不要忘记分号" class="headerlink" title="不要忘记分号"></a>不要忘记分号</h4><p>即使没有获得一致的认同，但在每一个表达式后面放置分号还是值得推荐的。这将使您的代码, 对于其他阅读代码的开发者来说，可读性，明确性更强。</p>
<p>否则: 在前面的章节里面已经提到，如果表达式的末尾没有添加分号，JavaScript的解释器会在自动添加一个，这可能会导致一些意想不到的结果。</p>
<h4 id="命名您的方法"><a href="#命名您的方法" class="headerlink" title="命名您的方法"></a>命名您的方法</h4><p>命名所有的方法，包含闭包和回调, 避免匿名方法。当剖析一个node应用的时候，这是特别有用的。命名所有的方法将会使您非常容易的理解内存快照中您正在查看的内容。</p>
<h4 id="变量、常量、函数和类的命名约定"><a href="#变量、常量、函数和类的命名约定" class="headerlink" title="变量、常量、函数和类的命名约定"></a>变量、常量、函数和类的命名约定</h4><p>当命名变量和方法的时候，使用 lowerCamelCase ，当命名类的时候，使用 UpperCamelCase （首字母大写），对于常量，则 UPPERCASE</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">MUTABLE_GLOBAL</span> = <span class="string">&quot;mutable value&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GLOBAL_CONSTANT</span> = <span class="string">&quot;immutable value&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CONFIG</span> = &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem</span></span><br><span class="line"><span class="comment">// in javascript Math.PI module</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.141592653589793</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303</span></span><br><span class="line"><span class="comment">// in nodejs http2 module</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HTTP_STATUS_OK</span> = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HTTP_STATUS_CREATED</span> = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for class name we use UpperCamelCase</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClassExample</span> &#123;</span><br><span class="line">  <span class="comment">// for static class properties we use UPPER_SNAKE_CASE</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">STATIC_PROPERTY</span> = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for functions names we use lowerCamelCase</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// for scoped variable names we use the const/let keyword and lowerCamelCase</span></span><br><span class="line">  <span class="keyword">const</span> someConstExample = <span class="string">&quot;immutable value&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> someMutableExample = <span class="string">&quot;mutable value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用const优于let，废弃var"><a href="#使用const优于let，废弃var" class="headerlink" title="使用const优于let，废弃var"></a>使用const优于let，废弃var</h4><p>使用const意味着一旦一个变量被分配，它不能被重新分配。使用const将帮助您免于使用相同的变量用于不同的用途，并使你的代码更清晰。如果一个变量需要被重新分配，以在一个循环为例，使用let声明它。let的另一个重要方面是，使用let声明的变量只在定义它的块作用域中可用。 var是函数作用域，不是块级作用域，既然您有const和let让您随意使用，那么<a target="_blank" rel="noopener" href="https://hackernoon.com/why-you-shouldnt-use-var-anymore-f109a58b9b70">不应该在ES6中使用var</a>。</p>
<h4 id="先require-而不是在方法内部"><a href="#先require-而不是在方法内部" class="headerlink" title="先require, 而不是在方法内部"></a>先require, 而不是在方法内部</h4><p>在每个文件的起始位置，在任何函数的前面和外部require模块。这种简单的最佳实践，不仅能帮助您轻松快速地在文件顶部辨别出依赖关系，而且避免了一些潜在的问题。</p>
<p>在Node.js中，require 是同步运行的。如果从函数中调用它们，它可能会阻塞其他请求，在更关键的时间得到处理。另外，如果所require的模块或它自己的任何依赖项抛出错误并使服务器崩溃，最好尽快查明它，如果该模块在函数中require的，则不能尽早发现这种的情况。</p>
<h4 id="require-文件夹，而不是文件"><a href="#require-文件夹，而不是文件" class="headerlink" title="require 文件夹，而不是文件"></a>require 文件夹，而不是文件</h4><p>当在一个文件夹中开发库&#x2F;模块，放置一个文件index.js暴露模块的 内部，这样每个消费者都会通过它。这将作为您模块的一个接口，并使未来的变化简单而不违反规则。</p>
<mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">SMSProvider</span> = <span class="built_in">require</span>(<span class="string">&#x27;./SMSProvider&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">SMSNumberResolver</span> = <span class="built_in">require</span>(<span class="string">&#x27;./SMSNumberResolver&#x27;</span>);</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">SMSProvider</span> = <span class="built_in">require</span>(<span class="string">&#x27;./SMSProvider/SMSProvider.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">SMSNumberResolver</span> = <span class="built_in">require</span>(<span class="string">&#x27;./SMSNumberResolver/SMSNumberResolver.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用-x3D-x3D-x3D-操作符"><a href="#使用-x3D-x3D-x3D-操作符" class="headerlink" title="使用 &#x3D;&#x3D;&#x3D; 操作符"></a>使用 &#x3D;&#x3D;&#x3D; 操作符</h4><p>对比弱等于 &#x3D;&#x3D;，优先使用严格的全等于 &#x3D;&#x3D;&#x3D; 。&#x3D;&#x3D; 将在它们转换为普通类型后比较两个变量。在 &#x3D;&#x3D;&#x3D; 中没有类型转换，并且两个变量必须是相同的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="string">&#x27;0&#x27;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>            <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>    <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; \t\r\n &#x27;</span> == <span class="number">0</span>     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果使用 &#x3D;&#x3D;&#x3D; ， 上面所有语句都将返回 false。</p>
<h4 id="使用-Async-Await-避免回调"><a href="#使用-Async-Await-避免回调" class="headerlink" title="使用 Async Await, 避免回调"></a>使用 Async Await, 避免回调</h4><p>Node 8 LTS现已全面支持异步等待。这是一种新的方式处理异步请求，取代回调和promise。Async-await是非阻塞的，它使异步代码看起来像是同步的。您可以给你的代码的最好的礼物是用async-await提供了一个更紧凑的，熟悉的，类似try catch的代码语法。</p>
<h4 id="使用-x3D-gt-箭头函数"><a href="#使用-x3D-gt-箭头函数" class="headerlink" title="使用 (&#x3D;&gt;) 箭头函数"></a>使用 (&#x3D;&gt;) 箭头函数</h4><p>尽管使用 async-await 和避免方法作为参数是被推荐的, 但当处理那些接受promise和回调的老的API的时候 - 箭头函数使代码结构更加紧凑，并保持了根方法上的语义上下文 (例如 ‘this’)。</p>
<h3 id="测试和总体的质量实践"><a href="#测试和总体的质量实践" class="headerlink" title="测试和总体的质量实践"></a>测试和总体的质量实践</h3><h4 id="至少，编写API（组件）测试"><a href="#至少，编写API（组件）测试" class="headerlink" title="至少，编写API（组件）测试"></a>至少，编写API（组件）测试</h4><p>大多数项目只是因为时间表太短而没有进行任何自动化测试，或者测试项目失控而正被遗弃。因此，优先从API测试开始，这是最简单的编写和提供比单元测试更多覆盖率的事情（你甚至可能不需要编码而进行API测试，像Postman。之后，如果您有更多的资源和时间，继续使用高级测试类型，如单元测试、DB测试、性能测试等。</p>
<h4 id="使用一个linter检测代码问题"><a href="#使用一个linter检测代码问题" class="headerlink" title="使用一个linter检测代码问题"></a>使用一个linter检测代码问题</h4><p>使用代码linter检查基本质量并及早检测反模式。在任何测试之前运行它, 并将其添加为预提交的git钩子, 以最小化审查和更正任何问题所需的时间。</p>
<h4 id="单元测试三要素"><a href="#单元测试三要素" class="headerlink" title="单元测试三要素"></a>单元测试三要素</h4><p>测试报告应该告诉那些不熟悉代码的读者（测试人员，DevOps 工程师，两年后的你），是否满足他们的要求。<br>所以测试报告需要包含：</p>
<ol>
<li>测试的是什么？例如，ProductsService.addNewProduct 方法</li>
<li>在什么场景下测试？例如，入参里没有价格。</li>
<li>预期的结果是什么？例如，新产品未获批准。</li>
</ol>
<mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. unit under test</span></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Products Service&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;Add new product&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//2. scenario and 3. expectation</span></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;When no price is specified, then the product status is pending approval&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProduct = <span class="keyword">new</span> <span class="title class_">ProductService</span>().<span class="title function_">add</span>(...);</span><br><span class="line">      <span class="title function_">expect</span>(newProduct.<span class="property">status</span>).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="string">&#x27;pendingApproval&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Products Service&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;Add new product&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;Should return the right status&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//hmm, what is this test checking? what are the scenario and expectation?</span></span><br><span class="line">      <span class="keyword">const</span> newProduct = <span class="keyword">new</span> <span class="title class_">ProductService</span>().<span class="title function_">add</span>(...);</span><br><span class="line">      <span class="title function_">expect</span>(newProduct.<span class="property">status</span>).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="string">&#x27;pendingApproval&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="用-AAA-模式构建单元测试"><a href="#用-AAA-模式构建单元测试" class="headerlink" title="用 AAA 模式构建单元测试"></a>用 AAA 模式构建单元测试</h4><p>对于单元测试，最大的挑战就是没有人力去做。产品代码已经让我们无暇分心。出于这个原因，测试代码必须非常简单且易于理解。</p>
<p>当阅读测试用例时，它不应该感觉像阅读命令式代码(循环，继承)，而更像HTML，一种声明性的体验。为了达到这个目的，保持 AAA 的约定，这样读者就可以毫不费力地解析测试意图。</p>
<ol>
<li><p>Arrange: 所有的设置代码目的是模拟场景。这包括实例化测试构造函数下的元数据，添加 DB 记录，在对象上 mocking&#x2F;stubbing ，以及任何其他准备代码</p>
</li>
<li><p>Act：执行测试中的单元。通常是一行代码。</p>
</li>
<li><p>Assert：确保接收到的值满足期望。通常是一行代码。</p>
</li>
</ol>
<mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">describe.<span class="title function_">skip</span>(<span class="string">&#x27;Customer classifier&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;When customer spent more than 500$, should be classified as premium&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//Arrange</span></span><br><span class="line">        <span class="keyword">const</span> customerToClassify = &#123;<span class="attr">spent</span>:<span class="number">505</span>, <span class="attr">joined</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="attr">id</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">DBStub</span> = sinon.<span class="title function_">stub</span>(dataAccess, <span class="string">&#x27;getCustomer&#x27;</span>)</span><br><span class="line">            .<span class="title function_">reply</span>(&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">classification</span>: <span class="string">&#x27;regular&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Act</span></span><br><span class="line">        <span class="keyword">const</span> receivedClassification = customerClassifier.<span class="title function_">classifyCustomer</span>(customerToClassify);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Assert</span></span><br><span class="line">        <span class="title function_">expect</span>(receivedClassification).<span class="title function_">toMatch</span>(<span class="string">&#x27;premium&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;Should be classified as premium&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> customerToClassify = &#123;<span class="attr">spent</span>:<span class="number">505</span>, <span class="attr">joined</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="attr">id</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">DBStub</span> = sinon.<span class="title function_">stub</span>(dataAccess, <span class="string">&#x27;getCustomer&#x27;</span>)</span><br><span class="line">        .<span class="title function_">reply</span>(&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">classification</span>: <span class="string">&#x27;regular&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> receivedClassification = customerClassifier.<span class="title function_">classifyCustomer</span>(customerToClassify);</span><br><span class="line">    <span class="title function_">expect</span>(receivedClassification).<span class="title function_">toMatch</span>(<span class="string">&#x27;premium&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="避免全局设置或全局源数据"><a href="#避免全局设置或全局源数据" class="headerlink" title="避免全局设置或全局源数据"></a>避免全局设置或全局源数据</h4><p>遵循黄金测试规则——保持测试用例非常简单。每个测试都应该添加并作用于它自己的DB行，以防止耦合和容易推断测试流。</p>
<mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;When updating site name, get successful confirmation&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">//Arrange - test is adding a fresh new records and acting on the records only</span></span><br><span class="line">  <span class="keyword">const</span> siteUnderTest = <span class="keyword">await</span> <span class="title class_">SiteService</span>.<span class="title function_">addSite</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;siteForUpdateTest&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Act</span></span><br><span class="line">  <span class="keyword">const</span> updateNameResult = <span class="keyword">await</span> <span class="title class_">SiteService</span>.<span class="title function_">changeName</span>(siteUnderTest, <span class="string">&#x27;newName&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Assert</span></span><br><span class="line">  <span class="title function_">expect</span>(updateNameResult).<span class="property">to</span>.<span class="title function_">be</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">before</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//Arrange - adding sites and admins data to our DB. Where is the data? outside. At some external json or migration framework</span></span><br><span class="line">  <span class="keyword">await</span> <span class="variable constant_">DB</span>.<span class="title class_">AddSeedDataFromJson</span>(<span class="string">&#x27;seed.json&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;When updating site name, get successful confirmation&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">//Arrange - I know that site name &#x27;portal&#x27; exists - I saw it in the seed files</span></span><br><span class="line">  <span class="keyword">const</span> siteToUpdate = <span class="keyword">await</span> <span class="title class_">SiteService</span>.<span class="title function_">getSiteByName</span>(<span class="string">&#x27;Portal&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Act</span></span><br><span class="line">  <span class="keyword">const</span> updateNameResult = <span class="keyword">await</span> <span class="title class_">SiteService</span>.<span class="title function_">changeName</span>(siteToUpdate, <span class="string">&#x27;newName&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Assert</span></span><br><span class="line">  <span class="title function_">expect</span>(updateNameResult).<span class="property">to</span>.<span class="title function_">be</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&#x27;When querying by site name, get the right site&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">//Act - I know that site name &#x27;portal&#x27; exists - I saw it in the seed files</span></span><br><span class="line">  <span class="keyword">const</span> siteToCheck = <span class="keyword">await</span> <span class="title class_">SiteService</span>.<span class="title function_">getSiteByName</span>(<span class="string">&#x27;Portal&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Assert</span></span><br><span class="line">  <span class="title function_">expect</span>(siteToCheck.<span class="property">name</span>).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">equal</span>(<span class="string">&#x27;Portal&#x27;</span>); <span class="comment">//Failure! The previous test change the name :[</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="经常检查易受攻击的依赖项"><a href="#经常检查易受攻击的依赖项" class="headerlink" title="经常检查易受攻击的依赖项"></a>经常检查易受攻击的依赖项</h4><p>即使是最著名的依赖项，如 Express ，也有已知的漏洞。使用社区和商业工具(如🔗<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v9/commands/npm-audit">npm audit</a>和🔗<a target="_blank" rel="noopener" href="https://snyk.io/">snyk.io</a>)可以很容易地解决这个问题。它们可以在每次构建时在 CI 平台上调用。</p>
<h4 id="给测试做标记"><a href="#给测试做标记" class="headerlink" title="给测试做标记"></a>给测试做标记</h4><p>不同的测试必须在不同的场景上运行，例如快速冒烟应该在开发人员保存或提交一个文件时运行；完整的端到端应该在新的请求被提交时运行。<br>这可以通过使用#cold #api #sanity等关键字标记测试来实现</p>
<h4 id="检查您的测试覆盖率"><a href="#检查您的测试覆盖率" class="headerlink" title="检查您的测试覆盖率"></a>检查您的测试覆盖率</h4><p>像<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/istanbuljs">Istanbul</a>&#x2F;<a target="_blank" rel="noopener" href="https://github.com/istanbuljs/nyc">NYC</a>这样的代码覆盖工具非常棒，原因有3个：</p>
<ol>
<li>免费。</li>
<li>它能帮助测试人员认识到测试覆盖率的减少。</li>
<li>它高亮测试覆盖的代码。</li>
</ol>
<h4 id="检查过期的依赖"><a href="#检查过期的依赖" class="headerlink" title="检查过期的依赖"></a>检查过期的依赖</h4><p>使用你习惯的工具例如 <code>npm outdated</code> 或者 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/npm-check-updates">npm-check-updates</a> 检擦过期的依赖。<br>在 CI 平台里注入这个检查，甚至在极端情况下汇报编译错误。<br>例如落后5个版本（本地版本是 1.3.1 而 最新仓库版本是 1.3.8），或者 该依赖已经被作者标记为已过期。</p>
<h4 id="使用类生成环境做端到端测试"><a href="#使用类生成环境做端到端测试" class="headerlink" title="使用类生成环境做端到端测试"></a>使用类生成环境做端到端测试</h4><p>使用实时数据做端到端测试曾今是 CI 平台中最薄弱的环节，因为它依赖于多个重量级的依赖，例如 DB 。 使用 docker-compose 做出接近真实生产环境用来测试。</p>
<h4 id="使用静态分析工具分析代码并重构"><a href="#使用静态分析工具分析代码并重构" class="headerlink" title="使用静态分析工具分析代码并重构"></a>使用静态分析工具分析代码并重构</h4><p>重构是迭代开发流程中的一个重要过程。移除代码异味（坏的代码实践）例如重复代码，过长函数，过长参数列表。这样可以使代码更易于维护。使用静态分析工具将帮助发现代码异味。集成这个步骤到 CI 平台。<a target="_blank" rel="noopener" href="https://www.sonarsource.com/">Sonar</a>或者<a target="_blank" rel="noopener" href="https://codeclimate.com/">Code Climate</a> 可以发现代码异味并告诉用户如何解决问题。</p>
<p>这些静态分析工具将补足 lint 工具例如 ESLint。大多数 lint 工具 关注单个文件的代码风格。静态分析工具关注多个文件的代码异味。</p>
<h4 id="仔细挑选-CI-平台"><a href="#仔细挑选-CI-平台" class="headerlink" title="仔细挑选 CI 平台"></a>仔细挑选 CI 平台</h4><p>曾经，CI世界就是易于扩展的<a target="_blank" rel="noopener" href="https://jenkins.io/">Jenkins</a> vs 简单方便的SaaS方案。游戏正在改变，比如SaaS提供者<a target="_blank" rel="noopener" href="https://circleci.com/">CircleCI</a>和<a target="_blank" rel="noopener" href="https://www.travis-ci.com/">Travis</a>提供了强大的解决方案，包含最小化设置时间的Docker容器，而Jenkins也尝试在简单易用性上做文章而提高竞争性。虽然您可以在云上设置丰富的CI解决方案, 如果它需要控制更多的细节Jenkins仍然是选择的平台。最终的选择归结为CI过程自定义的范围: 免安装，方便设置的云供应商允许运行自定义shell命令、自定义的docker image、调整工作流、运行matrix build和其他丰富的功能。但是, 如果使用像Java这样的正式编程语言来控制基础结构或编程CI逻辑 - Jenkins可能仍然是首选。否则, 考虑选择简单方便和设置自由的云选项。</p>
<h4 id="单独测试中间件"><a href="#单独测试中间件" class="headerlink" title="单独测试中间件"></a>单独测试中间件</h4><p>许多人逃避测试中间件， 认为它只代表系统一小部分并且需要一个实时的Express服务。这两个原因都时错误的。中间件虽然小，但会影响所有或大多数请求。中间件可以当作入参为<code>&#123;req,res&#125;</code>的JS对象的单纯函数测试。</p>
<p>要测试中间件函数，只需调用它并监视(例如使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/sinon">Sinon</a>)与{req,res}对象的交互，以确保函数执行正确的操作。库<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/node-mocks-http">node-mock-http</a>甚至更进一步，将{req,res}对象与监视它们的行为一起分解。例如，它可以断言在res对象上设置的http状态是否与期望匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the middleware we want to test</span></span><br><span class="line"><span class="keyword">const</span> unitUnderTest = <span class="built_in">require</span>(<span class="string">&quot;./middleware&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> httpMocks = <span class="built_in">require</span>(<span class="string">&quot;node-mocks-http&quot;</span>);</span><br><span class="line"><span class="comment">//Jest syntax, equivalent to describe() &amp; it() in Mocha</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;A request without authentication header, should return http status 403&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> request = httpMocks.<span class="title function_">createRequest</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/user/42&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="attr">authentication</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> response = httpMocks.<span class="title function_">createResponse</span>();</span><br><span class="line">  <span class="title function_">unitUnderTest</span>(request, response);</span><br><span class="line">  <span class="title function_">expect</span>(response.<span class="property">statusCode</span>).<span class="title function_">toBe</span>(<span class="number">403</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="上线实践"><a href="#上线实践" class="headerlink" title="上线实践"></a>上线实践</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>基本来说，当在生产环境中发生意外时，监控意味着你能够很容易识别它们。比如，通过电子邮件或Slack获得通知。挑战在于选择既能满足你的需求又不会破坏防护的合适工具集。我建议, 首先定义一组核心的度量标准, 这些指标必须被监视, 以确保健康状态 – CPU, 服务器RAM, Node进程RAM（小于1.4GB），最后一分钟的错误数量，进程重启次数，平均响应时间。然后去看看你可能喜欢的一些高级功能，并添加到你的愿望清单。一些高级监控功能的例子：DB分析，跨服务测量（即测量业务事务），前端集成，将原始数据展示给自定义BI客户端，Slack 通知等等。</p>
<p>要实现高级功能需要冗长的设置或购买诸如Datadog，Newrelic之类的商业产品。不幸的是，实现基本功能也并不容易，因为一些测量标准是与硬件相关的（CPU），而其它则在node进程内（内部错误），因此所有简单的工具都需要一些额外的设置。例如，云供应商监控解决方案（例如AWS CloudWatch, Google StackDriver)能立即告诉您硬件度量标准，但不涉及内部应用程序行为。另一方面，基于日志的解决方案（如ElasticSearch）默认缺少硬件视图。解决方案是通过缺少的指标来增加您的选择，例如，一个流行的选择是将应用程序日志发送到Elastic stack并配置一些额外的代理（例如Beat）来共享硬件相关信息以获得完整的展现。</p>
<h4 id="使用智能日志使你的应用程序变得清晰"><a href="#使用智能日志使你的应用程序变得清晰" class="headerlink" title="使用智能日志使你的应用程序变得清晰"></a>使用智能日志使你的应用程序变得清晰</h4><p>无论如何，您要打印日志，而且需要一些可以在其中跟踪错误和核心指标的接口来展示生产环境信息（例如，每小时发生了多少错误，最慢的API节点是哪一个）为什么不在健壮的日志框架中进行一些适度的尝试呢? 要实现这一目标，需要在三个步骤上做出深思熟虑的决定:</p>
<ol>
<li><p>智能日志 – 在最基本的情况下，您需要使用像Winston, Bunyan这样有信誉的日志库，在每个事务开始和结束时输出有意义的信息。还可以考虑将日志语句格式化为JSON，并提供所有上下文属性（如用户id、操作类型等）。这样运维团队就可以在这些字段上操作。在每个日志行中包含一个唯一的transaction ID，更多的信息查阅条款 “Write transaction-id to log”。最后要考虑的一点还包括一个代理，它记录系统资源，如内存和CPU，比如Elastic Beat。</p>
</li>
<li><p>智能聚合 – 一旦您在服务器文件系统中有了全面的信息，就应该定期将这些信息推送到一个可以聚合、处理和可视化数据的系统中。例如，Elastic stack是一种流行的、自由的选择，它提供所有组件去聚合和产生可视化数据。许多商业产品提供了类似的功能，只是它们大大减少了安装时间，不需要主机托管。</p>
</li>
<li><p>智能可视化 – 现在的信息是聚合和可搜索的, 一个可以满足仅仅方便地搜索日志的能力, 可以走得更远, 没有编码或花费太多的努力。我们现在可以显示一些重要的操作指标, 如错误率、平均一天CPU使用, 在过去一小时内有多少新用户选择, 以及任何其他有助于管理和改进我们应用程序的指标。</p>
</li>
</ol>
<h4 id="委托任何可能的-例如静态内容，gzip-到反向代理"><a href="#委托任何可能的-例如静态内容，gzip-到反向代理" class="headerlink" title="委托任何可能的 (例如静态内容，gzip) 到反向代理"></a>委托任何可能的 (例如静态内容，gzip) 到反向代理</h4><p>过度使用Express，及其丰富的中间件去提供网络相关的任务，如服务静态文件，gzip 编码，throttling requests，SSL termination等，是非常诱人的。由于Node.js的单线程模型，这将使CPU长时间处于忙碌状态 (请记住，node的执行模型针对短任务或异步IO相关任务进行了优化)，因此这是一个性能消耗。一个更好的方法是使用专注于处理网络任务的工具 – 最流行的是nginx和HAproxy，它们也被最大的云供应商使用，以减轻在Node.js进程上所面临的负载问题。</p>
<h4 id="锁定依赖版本"><a href="#锁定依赖版本" class="headerlink" title="锁定依赖版本"></a>锁定依赖版本</h4><p>您的代码依赖于许多外部包，假设它“需要”和使用momentjs-2.1.4，默认情况下，当布署到生产中时，npm可能会获得momentjs 2.1.5，但不幸的是，这将带来一些新的bug。使用npm配置文件和设置 –save-exact&#x3D;true 指示npm去完成安装，以便下次运行 npm install（在生产或在Docker容器中，您计划将其用于测试）时，将获取相同的依赖版本。另一种可选择受欢迎的方法是使用一个shrinkwrap文件（很容易使用npm生成）指出应该安装哪些包和版本，这样就不需要环境来获取新版本了。</p>
<ul>
<li>更新: 在npm5中，使用.shrinkwrap依赖项会被自动锁定。Yarn，一个新兴的包管理器，默认情况下也会锁定依赖项。</li>
</ul>
<p>npmrc文件指示npm使用精确的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在项目目录上保存这个为.npmrc 文件</span><br><span class="line">save-exact:true</span><br></pre></td></tr></table></figure>

<p>shirnkwrap.json文件获取准确的依赖关系树:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;A&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;B&quot;: &#123;</span><br><span class="line">            &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">            &quot;dependencies&quot;: &#123;</span><br><span class="line">                &quot;C&quot;: &#123;</span><br><span class="line">                    &quot;version&quot;: &quot;0.1.0&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="保护和重启失败进程"><a href="#保护和重启失败进程" class="headerlink" title="保护和重启失败进程"></a>保护和重启失败进程</h4><p>在基本级别，必须保护Node进程并在出现故障时重新启动。简单地说, 对于那些小应用和不使用容器的应用 – 像这样的工具 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/pm2-docker">PM2</a> 是完美的，因为它们带来简单性，重启能力以及与Node的丰富集成。其他具有强大Linux技能的人可能会使用systemd并将Node作为服务运行。对于使用Docker或任何容器技术的应用程序来说，事情会变得更加有趣，因为集群管理和协调工具（比如AWS ECS，Kubernetes等）会完成部署，监视和保持容器健康的功能。拥有所有丰富的集群管理功能（包括容器重启），为什么还要与其他工具（如PM2）混为一谈？这里并没有可靠的答案。将PM2保留在容器（主要是其容器特定版本pm2-docker）中作为第一个守护层是有充分的理由的 - 在主机容器要求正常重启时，重新启动更快，并提供特定于node的功能比如向代码发送信号。其他选择可能会避免不必要的层。总而言之，没有一个解决方案适合所有人，但了解这些选择是最重要的。</p>
<h4 id="利用CPU多核"><a href="#利用CPU多核" class="headerlink" title="利用CPU多核"></a>利用CPU多核</h4><p>这应该不会让人感到意外, 在其基本形式上，Node运行在单进程，单线程，单个CPU上。购买了一个强大的包含4个或8个CPU的硬件，只使用一个听起来是不可思议的，对吗？适合中型应用最快的解决方案是使用Node的Cluster模块，它在10行代码中为每个逻辑核心和路由请求产生一个进程，进程之间以round-robin的形式存在。更好的是使用PM2，它通过一个简单的接口和一个很酷的监视UI来给cluster模块裹上糖衣。虽然这个解决方案对传统应用程序很有效，但它可能无法满足需要顶级性能和健壮的devops流的应用。对于那些高级的用例，考虑使用自定义部署脚本复制NODE进程，并使用像nginx 这样的专门的工具进行负载均衡，或者使用像AWS ECS或Kubernetees这样的容器引擎，这些工具具有部署和复制进程的高级特性。</p>
<h4 id="创建维护端点"><a href="#创建维护端点" class="headerlink" title="创建维护端点"></a>创建维护端点</h4><p>维护端点是一个简单的安全的HTTP API, 它是应用程序代码的一部分, 它的用途是让ops&#x2F;生产团队用来监视和公开维护功能。例如, 它可以返回进程的head dump (内存快照), 报告是否存在内存泄漏, 甚至允许直接执行 REPL 命令。在常规的 devops 工具 (监视产品、日志等) 无法收集特定类型的信息或您选择不购买&#x2F;安装此类工具时, 需要使用此端点。黄金法则是使用专业的和外部的工具来监控和维护生产环境, 它们通常更加健壮和准确的。这就意味着, 一般的工具可能无法提取特定于node或应用程序的信息 – 例如, 如果您希望在 GC 完成一个周期时生成内存快照 – 很少有 npm 库会很乐意为您执行这个, 但流行的监控工具很可能会错过这个功能。</p>
<p>使用代码生产head dump:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heapdump = <span class="built_in">require</span>(<span class="string">&#x27;heapdump&#x27;</span>);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/ops/headump&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    logger.<span class="title function_">info</span>(<span class="string">`About to generate headump`</span>);</span><br><span class="line">    heapdump.<span class="title function_">writeSnapshot</span>(<span class="keyword">function</span> (<span class="params">err, filename</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;headump file is ready to be sent to the caller&#x27;</span>, filename);</span><br><span class="line">        fs.<span class="title function_">readFile</span>(filename, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            res.<span class="title function_">end</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用APM产品确保用户体验"><a href="#使用APM产品确保用户体验" class="headerlink" title="使用APM产品确保用户体验"></a>使用APM产品确保用户体验</h4><p>APM（应用程序性能监视）指的是一个产品系列, 目的是从端到端，也从客户的角度监控应用程序的性能。虽然传统的监控解决方案侧重于异常和独立的技术指标 (例如错误跟踪、检测慢速服务器节点等), 在现实世界中, 我们的应用程序可能会在没有任何代码异常的情况下让用户使用起来感到失望, 例如, 如果某些中间件服务执行得非常慢。APM 产品从端到端检测用户体验, 例如, 给定一个包含前端 UI 和多个分布式服务的系统 – 一些 APM 产品可以告诉您, 一个跨过多个层的事务的速度有多快。它可以判断用户体验是否可靠, 并指出问题所在。这种诱人的产品通常有一个相对较高的价格标签, 因此, 对于需要超越一般的监测的，大规模的和复杂的产品, 它们是值得推荐的。</p>
<h4 id="为生产环境准备代码"><a href="#为生产环境准备代码" class="headerlink" title="为生产环境准备代码"></a>为生产环境准备代码</h4><p>以下是一个开发技巧的列表，它极大地影响了产品的维护和稳定性：</p>
<ul>
<li>十二因素指南 — 熟悉<a target="_blank" rel="noopener" href="https://12factor.net/">12因素</a>指南</li>
<li>无状态 — 在一个特定的web服务器上不保存本地数据（请参阅相关条目 - “Be Stateless”）</li>
<li>高速缓存 — 大量使用缓存，但不会因为缓存不匹配而产生错误</li>
<li>测试内存 — 测量内存的使用和泄漏，是作为开发流程的一部分，诸如“memwatch”之类的工具可以极大地促进这一任务</li>
<li>命名函数 — 将匿名函数(例如，内联callbabk)的使用最小化，因为一个典型的内存分析器为每个方法名提供内存使用情况</li>
<li>使用CI工具 — 在发送到生产前使用CI工具检测故障。例如，使用ESLint来检测引用错误和未定义的变量。使用–trace-sync-io来识别用了同步api的代码(而不是异步版本)<br>明确的日志 — 包括在每个日志语句中希望用json格式记录上下文信息，以便于日志聚合工具，如Elastic可以在这些属性上搜索(请参阅相关条目 – “Increase visibility using smart logs”)。此外，还包括标识每个请求的事务id，并允许将描述相同事务的行关联起来(请参阅 — “Include Transaction-ID”)</li>
<li>错误管理 — 错误处理是Node.js生产站点的致命弱点 – 许多Node进程由于小错误而崩溃，然而其他Node进程则会在错误的状态下存活，而不是崩溃。设置你的错误处理策略绝对是至关重要的, 在这里阅读我的(错误处理的最佳实践)(<a target="_blank" rel="noopener" href="http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/">http://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/</a>)</li>
</ul>
<h4 id="测量和防范内存使用情况"><a href="#测量和防范内存使用情况" class="headerlink" title="测量和防范内存使用情况"></a>测量和防范内存使用情况</h4><p>在一个完美的开发过程中, Web开发人员不应该处理内存泄漏问题。 实际上，内存问题是一个必须了解的Node已知的问题。首先，内存使用必须不断监视.在开发和小型生产站点上，您可以使用Linux命令或NPM工具和库（如node-inspector和memwatch）来手动测量。 这个人工操作的主要缺点是它们需要一个人进行积极的监控 - 对于正规的生产站点来说，使用鲁棒性监控工具是非常重要的，例如（AWS CloudWatch，DataDog或任何类似的主动系统），当泄漏发生时提醒。 防止泄漏的开发指南也很少：避免将数据存储在全局级别，使用动态大小的流数据，使用let和const限制变量范围。</p>
<h4 id="在node外处理您的前端资产"><a href="#在node外处理您的前端资产" class="headerlink" title="在node外处理您的前端资产"></a>在node外处理您的前端资产</h4><p>在一个经典的 web 应用中，后端返回前端资源&#x2F;图片给浏览器, 在node的世界，一个非常常见的方法是使用 Express 静态中间件, 以数据流的形式把静态文件返回到客户端。但是, node并不是一个典型的 web应用, 因为它使用单个线程，对于同时服务多个文件，未经过任何优化。相反, 考虑使用反向代理、云存储或 CDN (例如Nginx, AWS S3, Azure Blob 存储等), 对于这项任务, 它们做了很多优化，并获得更好的吞吐量。例如, 像 nginx 这样的专业中间件在文件系统和网卡之间的直接挂钩, 并使用多线程方法来减少多个请求之间的干预。</p>
<p>您的最佳解决方案可能是以下形式之一:</p>
<ol>
<li>反向代理 – 您的静态文件将位于您的node应用的旁边, 只有对静态文件文件夹的请求才会由位于您的node应用前面的代理 (如 nginx) 提供服务。使用这种方法, 您的node应用负责部署静态文件, 而不是为它们提供服务。你的前端的同事会喜欢这种方法, 因为它可以防止 cross-origin-requests 的前端请求。</li>
<li>云存储 – 您的静态文件将不会是您的node应用内容的一部分, 他们将被上传到服务, 如 AWS S3, Azure BlobStorage, 或其他类似的服务, 这些服务为这个任务而生。使用这种方法, 您的node应用即不负责部署静态文件, 也不为它们服务, 因此, 在node和前端资源之间完全解耦, 这是由不同的团队处理。</li>
</ol>
<h4 id="保持服务器无状态"><a href="#保持服务器无状态" class="headerlink" title="保持服务器无状态"></a>保持服务器无状态</h4><p>确保服务器无状态，随时可以更换，并无任何负面影响。</p>
<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//典型错误1: 保存上传文件在本地服务器上</span></span><br><span class="line"><span class="keyword">var</span> multer  = <span class="built_in">require</span>(<span class="string">&#x27;multer&#x27;</span>) <span class="comment">// 处理multipart上传的express中间件</span></span><br><span class="line"><span class="keyword">var</span> upload = <span class="title function_">multer</span>(&#123; <span class="attr">dest</span>: <span class="string">&#x27;uploads/&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/photos/upload&#x27;</span>, upload.<span class="title function_">array</span>(<span class="string">&#x27;photos&#x27;</span>, <span class="number">12</span>), <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//典型错误2: 在本地文件或者内存中，保存授权会话（密码）</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FileStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;session-file-store&#x27;</span>)(session);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">store</span>: <span class="keyword">new</span> <span class="title class_">FileStore</span>(options),</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//典型错误3: 在全局对象中保存信息</span></span><br><span class="line"><span class="title class_">Global</span>.<span class="property">someCacheLike</span>.<span class="property">result</span> = &#123;somedata&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用工具自动检测有漏洞的依赖项"><a href="#使用工具自动检测有漏洞的依赖项" class="headerlink" title="使用工具自动检测有漏洞的依赖项"></a>使用工具自动检测有漏洞的依赖项</h4><p>现代node应用有数十个, 有时是数以百计的依赖。如果您使用的任何依赖项存在已知的安全漏洞, 您的应用也很容易受到攻击。 下列工具自动检查依赖项中的已知安全漏洞: <a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/audit">npm audit</a> - Node 安全工程 <a target="_blank" rel="noopener" href="https://snyk.io/">snyk</a> - 持续查找和修复依赖中的漏洞。</p>
<h4 id="在每一个log语句中指明-‘TransactionId’"><a href="#在每一个log语句中指明-‘TransactionId’" class="headerlink" title="在每一个log语句中指明 ‘TransactionId’"></a>在每一个log语句中指明 ‘TransactionId’</h4><p>一个典型的日志是来自所有组件和请求的条目的仓库。当检测到一些可疑行或错误时，为了与其他属于同一特定流程的行（如用户“约翰”试图购买某物）相匹配，就会变得难以应付。特别在微服务环境下，当一个请求&#x2F;交易可能跨越多个计算机，这变得更加重要和具有挑战性。解决这个问题，可以通过指定一个唯一的事务标识符给从相同的请求过来的所有条目，这样当检测到一行，可以复制这个id，并搜索包含这个transaction id的每一行。但是，在node中实现这个不是那么直截了当的，这是由于它的单线程被用来服务所有的请求 – 考虑使用一个库，它可以在请求层对数据进行分组 – 在下一张幻灯片查看示例代码。当调用其它微服务，使用HTTP头“x-transaction-id”传递transaction id去保持相同的上下文。</p>
<h4 id="配置环境变量-NODE-ENV-x3D-production"><a href="#配置环境变量-NODE-ENV-x3D-production" class="headerlink" title="配置环境变量 NODE_ENV &#x3D; production"></a>配置环境变量 NODE_ENV &#x3D; production</h4><p>进程的环境变量是一组键值对，可用于任何运行程序，通常用于配置。虽然可以使用其他任何变量，但Node鼓励使用一个名为NODE_ENV的变量来标记我们是否正在开发。这一决定允许组件在开发过程中能提供更好的诊断，例如禁用缓存或发出冗长的日志语句。任何现代部署工具 — Chef、Puppet、CloudFormation等 — 在部署时都支持设置环境变量。</p>
<h4 id="设计自动化、原子化和零停机时间部署"><a href="#设计自动化、原子化和零停机时间部署" class="headerlink" title="设计自动化、原子化和零停机时间部署"></a>设计自动化、原子化和零停机时间部署</h4><p>研究表明，执行许多部署的团队降低了严重上线问题的可能性。不需要危险的手动步骤和服务停机时间的快速和自动化部署大大改善了部署过程。你应该达到使用Docker结合CI工具，使他们成为简化部署的行业标准。</p>
<h4 id="使用-Node-js-的-LTS-版本"><a href="#使用-Node-js-的-LTS-版本" class="headerlink" title="使用 Node.js 的 LTS 版本"></a>使用 Node.js 的 LTS 版本</h4><p>确保您在正式环境中使用的是LTS（长期支持）版本的Node.js来获取关键错误的修复、安全更新和性能改进。</p>
<p>LTS版本的Node.js至少支持18个月，并由偶数版本号（例如 4、6、8）表示。它们最适合生产环境，因为LTS的发行线专注于稳定性和安全性，而“Current”版本发布寿命较短，代码更新更加频繁。LTS版本的更改仅限于稳定性错误修复、安全更新、合理的npm更新、文档更新和某些可以证明不会破坏现有应用程序的性能改进。</p>
<h4 id="应用程序不要处理日志保存"><a href="#应用程序不要处理日志保存" class="headerlink" title="应用程序不要处理日志保存"></a>应用程序不要处理日志保存</h4><p>应用程序应更关注于逻辑代码。关于日志保存，例如保存到哪个文件，哪个数据库，这些不是应用程序应该管的。</p>
<p>应用程序只需要把日志输出到 stdout&#x2F;stderr 中, Docker 的 log-driver 复制具体的日志保存。</p>
<mark class="label success">推荐</mark>:

<p>在应用程序中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> winston.<span class="title class_">Logger</span>(&#123;</span><br><span class="line">  <span class="attr">level</span>: <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">  <span class="attr">transports</span>: [</span><br><span class="line">    <span class="keyword">new</span> (winston.<span class="property">transports</span>.<span class="property">Console</span>)()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">logger.<span class="title function_">log</span>(<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;Test Log Message with some parameter %s&#x27;</span>, <span class="string">&#x27;some parameter&#x27;</span>, &#123; <span class="attr">anything</span>: <span class="string">&#x27;This is metadata&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在Docker容器的<code>daemon.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splunk&quot;</span><span class="punctuation">,</span> <span class="comment">// just using Splunk as an example, it could be another storage type</span></span><br><span class="line">  <span class="attr">&quot;log-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;splunk-token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;splunk-url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="生产模式下使用-npm-ci-安装依赖"><a href="#生产模式下使用-npm-ci-安装依赖" class="headerlink" title="生产模式下使用 npm ci 安装依赖"></a>生产模式下使用 npm ci 安装依赖</h4><ul>
<li>如果没有 <code>package-lock.json</code> 或该文件与 <code>package.json</code> 不相符，则报错失败。</li>
<li>自动删除 <code>node_modules</code> 文件夹。</li>
<li>更快。参考 <a target="_blank" rel="noopener" href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable">the release blog post</a></li>
</ul>
<h3 id="安全最佳实践"><a href="#安全最佳实践" class="headerlink" title="安全最佳实践"></a>安全最佳实践</h3><h4 id="拥护linter安全准则"><a href="#拥护linter安全准则" class="headerlink" title="拥护linter安全准则"></a>拥护linter安全准则</h4><p>ESLint 和 TSLint 的安全插件例如<a target="_blank" rel="noopener" href="https://github.com/eslint-community/eslint-plugin-security">eslint-plugin-security</a> 和 <a target="_blank" rel="noopener" href="https://github.com/webschik/tslint-config-security">tslint-config-security</a> 提供一系列风险代码安全检查。</p>
<h4 id="使用负载均衡或中间件处理并发请求"><a href="#使用负载均衡或中间件处理并发请求" class="headerlink" title="使用负载均衡或中间件处理并发请求"></a>使用负载均衡或中间件处理并发请求</h4><p>应该在应用程序中实现速率限制，以保护Node.js应用程序不会同时被过多的请求所淹没。速率限制任务最好使用专为该任务设计的服务执行，例如nginx，但是也可以使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/rate-limiter-flexible">rate-limiter-flexible</a> 包或中间件，例如Express.js应用程序的 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/express-rate-limit">express-rate-limiter</a> 。</p>
<p>rate-limiter-flexible 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">RateLimiterRedis</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;rate-limiter-flexible&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = redis.<span class="title function_">createClient</span>(&#123;</span><br><span class="line"> <span class="attr">enable_offline_queue</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum 20 requests per second</span></span><br><span class="line"><span class="keyword">const</span> rateLimiter = <span class="keyword">new</span> <span class="title class_">RateLimiterRedis</span>(&#123;</span><br><span class="line"> <span class="attr">storeClient</span>: redisClient,</span><br><span class="line"> <span class="attr">points</span>: <span class="number">20</span>,</span><br><span class="line"> <span class="attr">duration</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">blockDuration</span>: <span class="number">2</span>, <span class="comment">// block for 2 seconds if consumed more than 20 points per second</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rateLimiterRes = <span class="keyword">await</span> rateLimiter.<span class="title function_">consume</span>(req.<span class="property">socket</span>.<span class="property">remoteAddress</span>);</span><br><span class="line">  <span class="comment">// Some app logic here</span></span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">429</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Too Many Requests&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> .<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>express-rate-limiter 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">RateLimit</span> = <span class="built_in">require</span>(<span class="string">&#x27;express-rate-limit&#x27;</span>);</span><br><span class="line"><span class="comment">// important if behind a proxy to ensure client IP is passed to req.ip</span></span><br><span class="line">app.<span class="title function_">enable</span>(<span class="string">&#x27;trust proxy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiLimiter = <span class="keyword">new</span> <span class="title class_">RateLimit</span>(&#123;</span><br><span class="line">  <span class="attr">windowMs</span>: <span class="number">15</span>*<span class="number">60</span>*<span class="number">1000</span>, <span class="comment">// 15 minutes</span></span><br><span class="line">  <span class="attr">max</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// only apply to requests that begin with /user/</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user/&#x27;</span>, apiLimiter);</span><br></pre></td></tr></table></figure>

<h4 id="把机密信息从配置文件中抽离出来，或者使用包对其加密"><a href="#把机密信息从配置文件中抽离出来，或者使用包对其加密" class="headerlink" title="把机密信息从配置文件中抽离出来，或者使用包对其加密"></a>把机密信息从配置文件中抽离出来，或者使用包对其加密</h4><p>最常见最安全的提供Nodejs访问机密的方法是把它们保存在系统的环境变量中。一旦设置，程序可以用<code>process.env</code>访问它们。<br>对于需要在源代码控制中保存机密的情况，可以使用加密包例如<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cryptr">cryptr</a>加密文本。</p>
<p>系统环境变量示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> azure = <span class="built_in">require</span>(<span class="string">&#x27;azure&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiKey = process.<span class="property">env</span>.<span class="property">AZURE_STORAGE_KEY</span>;</span><br><span class="line"><span class="keyword">const</span> blobService = azure.<span class="title function_">createBlobService</span>(apiKey);</span><br></pre></td></tr></table></figure>

<p><code>cryptr</code>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Cryptr</span> = <span class="built_in">require</span>(<span class="string">&#x27;cryptr&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cryptr = <span class="keyword">new</span> <span class="title class_">Cryptr</span>(process.<span class="property">env</span>.<span class="property">SECRET</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> accessToken = cryptr.<span class="title function_">decrypt</span>(<span class="string">&#x27;e74d7c0de21e72aaffc8f2eef2bdb7c1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(accessToken);  <span class="comment">// outputs decrypted string which was not stored in source control</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-ORM-x2F-ODM-库防止查询注入漏洞"><a href="#使用-ORM-x2F-ODM-库防止查询注入漏洞" class="headerlink" title="使用 ORM&#x2F;ODM 库防止查询注入漏洞"></a>使用 ORM&#x2F;ODM 库防止查询注入漏洞</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/typeorm/typeorm">TypeORM</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sequelize/sequelize">sequelize</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Automattic/mongoose">mongoose</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/knex/knex">Knex</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Vincit/objection.js">Objection.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/balderdashy/waterline">waterline</a></li>
</ul>
<h4 id="通用安全最佳实践集合"><a href="#通用安全最佳实践集合" class="headerlink" title="通用安全最佳实践集合"></a>通用安全最佳实践集合</h4><p>这些是与Node.js不直接相关的安全建议的集合-Node的实现与任何其他语言没有太大的不同。</p>
<h5 id="使用-HTTPS-加密连接"><a href="#使用-HTTPS-加密连接" class="headerlink" title="使用 HTTPS 加密连接"></a>使用 HTTPS 加密连接</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="comment">// The path should be changed accordingly to your setup</span></span><br><span class="line">    <span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./sslcert/fullchain.pem&#x27;</span>),</span><br><span class="line">    <span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./sslcert/privkey.pem&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line">https.<span class="title function_">createServer</span>(options, app).<span class="title function_">listen</span>(<span class="number">443</span>);</span><br></pre></td></tr></table></figure>

<h5 id="安全地比较秘密值和哈希值"><a href="#安全地比较秘密值和哈希值" class="headerlink" title="安全地比较秘密值和哈希值"></a>安全地比较秘密值和哈希值</h5><p>当比较秘密值或像 HMAC digests 这样的哈希值时，应该使用 <a target="_blank" rel="noopener" href="https://nodejs.org/dist/latest-v9.x/docs/api/crypto.html#crypto_crypto_timingsafeequal_a_b"><code>crypto.timingSafeEqual(a, b)</code></a> 函数，Node.js v6.6.0开始提供。</p>
<h5 id="使用Node-js生成随机字符串"><a href="#使用Node-js生成随机字符串" class="headerlink" title="使用Node.js生成随机字符串"></a>使用Node.js生成随机字符串</h5><p>当你必须生成安全的随机字符串时，使用 <a target="_blank" rel="noopener" href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback"><code>crypto.randomBytes(size, [callback])</code></a> 函数使用系统提供的可用熵。</p>
<h5 id="OWASP-建议"><a href="#OWASP-建议" class="headerlink" title="OWASP 建议"></a>OWASP 建议</h5><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/commonsecuritybestpractices.md">参考</a></p>
<h4 id="调整-HTTP-响应头以加强安全性"><a href="#调整-HTTP-响应头以加强安全性" class="headerlink" title="调整 HTTP 响应头以加强安全性"></a>调整 HTTP 响应头以加强安全性</h4><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/secureheaders.md#http-strict-transport-security-hsts">参考</a></p>
<h4 id="经常自动检查易受攻击的依赖库"><a href="#经常自动检查易受攻击的依赖库" class="headerlink" title="经常自动检查易受攻击的依赖库"></a>经常自动检查易受攻击的依赖库</h4><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/dependencysecurity.md">参考</a></p>
<h4 id="保护用户的密码"><a href="#保护用户的密码" class="headerlink" title="保护用户的密码"></a>保护用户的密码</h4><p>始终散列用户密码，而不是将它们存储为文本。</p>
<ul>
<li>对于大多数用例，可以使用流行的库<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/bcrypt">bcrypt</a>。(最小：<code>cost:12</code>，密码长度必须小于64)</li>
<li>对于稍微难一点的本地解决方案，或无限大小的密码，请使用<a target="_blank" rel="noopener" href="https://nodejs.org/dist/latest-v14.x/docs/api/crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback">scrypt</a>函数。(最小值:N:32768, r:8, p:1)</li>
<li>对于 FIPS&#x2F;Government compliance ，使用本地加密模块中包含的较旧的<a target="_blank" rel="noopener" href="https://nodejs.org/dist/latest-v14.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback">PBKDF2</a>函数。(最小值:迭代:10000，长度:{salt: 16，密码:32})</li>
</ul>
<h4 id="转义输出"><a href="#转义输出" class="headerlink" title="转义输出"></a>转义输出</h4><p>发送给浏览器的不受信任数据可能会被执行, 而不是显示, 这通常被称为跨站点脚本(XSS)攻击。使用专用库将数据显式标记为不应执行的纯文本内容，可以减轻这种问题。</p>
<h4 id="验证传入的JSON-schemas"><a href="#验证传入的JSON-schemas" class="headerlink" title="验证传入的JSON schemas"></a>验证传入的JSON schemas</h4><p>验证传入请求的body payload，并确保其符合预期要求, 如果没有, 则快速报错。</p>
<h4 id="支持黑名单的JWT"><a href="#支持黑名单的JWT" class="headerlink" title="支持黑名单的JWT"></a>支持黑名单的JWT</h4><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/expirejwt.md">参考</a></p>
<h4 id="限制登录请求，防止暴力破解"><a href="#限制登录请求，防止暴力破解" class="headerlink" title="限制登录请求，防止暴力破解"></a>限制登录请求，防止暴力破解</h4><p>将更高特权的路由(如&#x2F;login或&#x2F;admin)暴露在没有速率限制的情况下，会使应用程序面临暴力破解密码字典攻击的风险。使用一种策略将请求限制在这样的路由上，可以通过限制基于请求属性(如ip)或主体参数(如用户名&#x2F;电子邮件地址)的允许尝试的数量来防止成功。</p>
<p>rate-limiter-flexible 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxWrongAttemptsByIPperDay = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> maxConsecutiveFailsByUsernameAndIP = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> limiterSlowBruteByIP = <span class="keyword">new</span> <span class="title class_">RateLimiterRedis</span>(&#123;</span><br><span class="line">  <span class="attr">storeClient</span>: redisClient,</span><br><span class="line">  <span class="attr">keyPrefix</span>: <span class="string">&#x27;login_fail_ip_per_day&#x27;</span>,</span><br><span class="line">  <span class="attr">points</span>: maxWrongAttemptsByIPperDay,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>,</span><br><span class="line">  <span class="attr">blockDuration</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>, <span class="comment">// Block for 1 day, if 100 wrong attempts per day</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> limiterConsecutiveFailsByUsernameAndIP = <span class="keyword">new</span> <span class="title class_">RateLimiterRedis</span>(&#123;</span><br><span class="line">  <span class="attr">storeClient</span>: redisClient,</span><br><span class="line">  <span class="attr">keyPrefix</span>: <span class="string">&#x27;login_fail_consecutive_username_and_ip&#x27;</span>,</span><br><span class="line">  <span class="attr">points</span>: maxConsecutiveFailsByUsernameAndIP,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">90</span>, <span class="comment">// Store number for 90 days since first fail</span></span><br><span class="line">  <span class="attr">blockDuration</span>: <span class="number">60</span>*<span class="number">60</span>, <span class="comment">// Block for 1 hour</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用非root用户运行Node-js"><a href="#使用非root用户运行Node-js" class="headerlink" title="使用非root用户运行Node.js"></a>使用非root用户运行Node.js</h4><p>根据“最小特权原则”，用户&#x2F;进程必须只能访问必要的信息和资源。向攻击者授予根访问权限打开了一个全新的恶意想法的世界，比如将流量路由到其他服务器。在实践中，大多数Node.js应用程序不需要root访问权限，也不使用这种特权运行。然而，有两种常见的场景可能会推动根用户使用:</p>
<ul>
<li>要访问特权端口(例如80端口)，Node.js必须以root身份运行</li>
<li>Docker容器默认以root(!)运行。建议Node.js web应用程序侦听非特权端口，并依赖像nginx这样的反向代理将传入的流量从端口80重定向到Node.js应用程序。在构建Docker映像时，高度安全的应用程序应该使用替代的非根用户运行容器。大多数Docker集群(如Swarm, Kubernetes)允许以声明的方式设置安全上下文</li>
</ul>
<h4 id="使用反向代理或中间件限制负载大小"><a href="#使用反向代理或中间件限制负载大小" class="headerlink" title="使用反向代理或中间件限制负载大小"></a>使用反向代理或中间件限制负载大小</h4><p>解析request主体(例如json编码的有效负载)是一项性能要求很高的操作，对于较大的请求尤其如此。在web应用程序中处理传入request时，应该限制它们各自有效负载的大小。</p>
<p>express 示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>(&#123; <span class="attr">limit</span>: <span class="string">&#x27;300kb&#x27;</span> &#125;)); <span class="comment">// body-parser defaults to a body size limit of 100kb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Request with json body</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/json&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if request payload content-type matches json, because body-parser does not check for content types</span></span><br><span class="line">    <span class="keyword">if</span> (!req.<span class="title function_">is</span>(<span class="string">&#x27;json&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">sendStatus</span>(<span class="number">415</span>); <span class="comment">// -&gt; Unsupported media type if request doesn&#x27;t have JSON body</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Hooray, it worked!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3000!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>nginx 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    # Limit the body size for ALL incoming requests to 1 MB</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    # Limit the body size for incoming requests to this specific server block to 1 MB</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /upload &#123;</span><br><span class="line">    ...</span><br><span class="line">    # Limit the body size for incoming requests to this route to 1 MB</span><br><span class="line">    client_max_body_size 1m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免JS-eval语法"><a href="#避免JS-eval语法" class="headerlink" title="避免JS eval语法"></a>避免JS eval语法</h4><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/avoideval.chinese.md">参考</a></p>
<h4 id="防止恶意RegEx让Node-js的单线程过载执行"><a href="#防止恶意RegEx让Node-js的单线程过载执行" class="headerlink" title="防止恶意RegEx让Node.js的单线程过载执行"></a>防止恶意RegEx让Node.js的单线程过载执行</h4><p> 正则表达式，在方便的同时，对JavaScript应用构成了真正的威胁，特别是Node.js平台。匹配文本的用户输入需要大量的CPU周期来处理。在某种程度上，正则处理是效率低下的，比如验证10个单词的单个请求可能阻止整个event loop长达6秒，并让CPU引火烧身。由于这个原因，偏向第三方的验证包，比如<a target="_blank" rel="noopener" href="https://github.com/chriso/validator.js">validator.js</a>，而不是采用正则。</p>
<h4 id="避免使用变量加载模块"><a href="#避免使用变量加载模块" class="headerlink" title="避免使用变量加载模块"></a>避免使用变量加载模块</h4><p>避免使用被指定为参数的路径变量导入(requiring&#x2F;importing)另一个文件, 因为该变量可能源自用户输入。此规则可以扩展到一般情况下的访问文件(例如，<code>fs.readFile()</code>)，或者包含源自用户输入的动态变量的其他敏感资源。</p>
<mark class="label success">推荐</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全</span></span><br><span class="line"><span class="keyword">const</span> uploadHelpers = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/upload&#x27;</span>);</span><br></pre></td></tr></table></figure>

<mark class="label danger">避免</mark>:

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全, 因为helperPath变量可能通过用户输入而改变</span></span><br><span class="line"><span class="keyword">const</span> uploadHelpers = <span class="built_in">require</span>(helperPath);</span><br></pre></td></tr></table></figure>

<h4 id="在沙箱中运行不安全代码"><a href="#在沙箱中运行不安全代码" class="headerlink" title="在沙箱中运行不安全代码"></a>在沙箱中运行不安全代码</h4><p>三个主要选项可以帮助实现这种隔离:</p>
<ul>
<li>一个专门的子进程 - 这提供了一个快速的信息隔离, 但要求制约子进程, 限制其执行时间, 并从错误中恢复。</li>
<li>一个基于云的无服务框架满足所有沙盒要求，但动态部署和调用Faas方法不是本部分的内容。</li>
<li>一些npm库，比如<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vm2">vm2</a>和<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/sandbox">sandbox</a>允许通过一行代码执行隔离代码。</li>
</ul>
<h4 id="处理子进程时要谨慎"><a href="#处理子进程时要谨慎" class="headerlink" title="处理子进程时要谨慎"></a>处理子进程时要谨慎</h4><p>尽管子进程非常棒, 但使用它们应该谨慎。如果无法避免传递用户输入，就必须经过脱敏处理。 未经脱敏处理的输入执行系统级逻辑的危险是无限的, 从远程代码执行到暴露敏感的系统数据, 甚至数据丢失。准备工作的检查清单可能是这样的:</p>
<ul>
<li>避免在每一种情况下的用户输入, 否则验证和脱敏处理。</li>
<li>使用user&#x2F;group标识限制父进程和子进程的权限。</li>
<li>在隔离环境中运行进程, 以防止在其他准备工作失败时产生不必要的副作用。</li>
</ul>
<p>未脱敏处理子进程的危害：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如, 以一个脚本为例, 它采用两个参数, 其中一个参数是未经脱敏处理的用户输入</span></span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&#x27;&quot;/path/to/test file/someScript.sh&quot; --someOption &#x27;</span> + input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; 想象一下, 如果用户只是输入&#x27;&amp;&amp; rm -rf --no-preserve-root /&#x27;类似的东西, 会发生什么</span></span><br><span class="line"><span class="comment">// 你会得到一个不想要的结果</span></span><br></pre></td></tr></table></figure>

<h4 id="隐藏客户端的错误详细信息"><a href="#隐藏客户端的错误详细信息" class="headerlink" title="隐藏客户端的错误详细信息"></a>隐藏客户端的错误详细信息</h4><p>默认情况下, 集成的express错误处理程序隐藏错误详细信息。但是, 极有可能, 您实现自己的错误处理逻辑与自定义错误对象(被许多人认为是最佳做法)。如果这样做, 请确保不将整个Error对象返回到客户端, 这可能包含一些敏感的应用程序详细信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// production error handler</span></span><br><span class="line"><span class="comment">// no stacktraces leaked to user</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">status</span>(err.<span class="property">status</span> || <span class="number">500</span>);</span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&#x27;error&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">message</span>: err.<span class="property">message</span>,</span><br><span class="line">        <span class="attr">error</span>: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="对npm或Yarn，配置2FA"><a href="#对npm或Yarn，配置2FA" class="headerlink" title="对npm或Yarn，配置2FA"></a>对npm或Yarn，配置2FA</h4><p>开发链中的任何步骤都应使用MFA(多重身份验证)进行保护, npm&#x2F;Yarn对于那些能够掌握某些开发人员密码的攻击者来说是一个很好的机会。使用开发人员凭据, 攻击者可以向跨项目和服务广泛安装的库中注入恶意代码。甚至可能在网络上公开发布。在npm中启用2因素身份验证（2-factor-authentication）, 攻击者几乎没有机会改变您的软件包代码。</p>
<h4 id="修改session中间件设置"><a href="#修改session中间件设置" class="headerlink" title="修改session中间件设置"></a>修改session中间件设置</h4><p>每个web框架和技术都有其已知的弱点-告诉攻击者我们使用的web框架对他们来说是很大的帮助。使用session中间件的默认设置, 可以以类似于<code>X-Powered-Byheader</code>的方式向模块和框架特定的劫持攻击公开您的应用。尝试隐藏识别和揭露技术栈的任何内容(例如:Nonde.js, express)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using the express session middleware</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">  <span class="attr">secret</span>: <span class="string">&#x27;youruniquesecret&#x27;</span>, <span class="comment">// secret string used in the signing of the session ID that is stored in the cookie</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;youruniquename&#x27;</span>, <span class="comment">// set a unique name to remove the default connect.sid</span></span><br><span class="line">  <span class="attr">cookie</span>: &#123;</span><br><span class="line">    <span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="comment">// minimize risk of XSS attacks by restricting the client from reading the cookie</span></span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// only send cookie over https</span></span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">60000</span>*<span class="number">60</span>*<span class="number">24</span> <span class="comment">// set cookie expiry length in ms</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="通过显式设置进程应崩溃的情况，以避免DOS攻击"><a href="#通过显式设置进程应崩溃的情况，以避免DOS攻击" class="headerlink" title="通过显式设置进程应崩溃的情况，以避免DOS攻击"></a>通过显式设置进程应崩溃的情况，以避免DOS攻击</h4><p>当错误未被处理时, Node进程将崩溃。即使错误被捕获并得到处理，许多最佳实践甚至建议退出。例如, Express会在任何异步错误上崩溃 - 除非使用catch子句包装路由。这将打开一个非常惬意的攻击点, 攻击者识别哪些输入会导致进程崩溃并重复发送相同的请求。没有即时补救办法, 但一些技术可以减轻苦楚: 每当进程因未处理的错误而崩溃，都会发出警报，验证输入并避免由于用户输入无效而导致进程崩溃，并使用catch将所有路由处理包装起来，并在请求中出现错误时, 考虑不要崩溃(与全局发生的情况相反)。</p>
<h4 id="避免不安全的重定向"><a href="#避免不安全的重定向" class="headerlink" title="避免不安全的重定向"></a>避免不安全的重定向</h4><p>当我们在 Node.js 或者 Express 中实现重定向时，在服务器端进行输入校验非常重要。当攻击者发现你没有校验用户提供的外部输入时，他们会在论坛、社交媒体以和其他公共场合发布他们精心制作的链接来诱使用户点击，以此达到漏洞利用的目的。</p>
<p>express 使用用户输入的不安全的重定向:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">session</span>.<span class="title function_">isAuthenticated</span>()) &#123;</span><br><span class="line">    res.<span class="title function_">redirect</span>(req.<span class="property">query</span>.<span class="property">url</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>建议的避免不安全重定向的方案是，避免依赖用户输入的内容来进行重定向。如果一定要使用用户输入的内容，可以通过使用白名单重定向的方式来避免暴露漏洞。</p>
<p>使用白名单实现安全的重定向:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> whitelist = &#123;</span><br><span class="line">  <span class="string">&#x27;https://google.com&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValidRedirect</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查url是否以/开头</span></span><br><span class="line">  <span class="keyword">if</span> (url.<span class="title function_">match</span>(<span class="regexp">/^\/(?!\/)/</span>)) &#123;</span><br><span class="line">    <span class="comment">// 前置我们的域名来确保（安全）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://example.com&#x27;</span> + url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则对照白名单列表</span></span><br><span class="line">  <span class="keyword">return</span> whitelist[url] ? url : <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">session</span>.<span class="title function_">isAuthenticated</span>()) &#123;</span><br><span class="line">    res.<span class="title function_">redirect</span>(<span class="title function_">getValidRedirect</span>(req.<span class="property">query</span>.<span class="property">url</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="避免将机密信息发布到NPM仓库"><a href="#避免将机密信息发布到NPM仓库" class="headerlink" title="避免将机密信息发布到NPM仓库"></a>避免将机密信息发布到NPM仓库</h4><p>您应该采取预防措施来避免偶然地将机密信息发布到npm仓库的风险。 一个 <code>.npmignore</code> 文件可以被用作忽略掉特定的文件或目录, 或者一个在 <code>package.json</code> 中的 <code>files</code> 数组可以起到一个白名单的作用.</p>
<h3 id="Docker-最佳实践"><a href="#Docker-最佳实践" class="headerlink" title="Docker 最佳实践"></a>Docker 最佳实践</h3><p><a target="_blank" rel="noopener" href="https://github.com/goldbergyoni/nodebestpractices#8-docker-best-practices">参考</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/downloads/images/reward/wechatpay.png" alt="唐李锦 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/downloads/images/reward/alipay.png" alt="唐李锦 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>唐李锦
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.tanglijin.top/2023/02/best-practice-01/" title="最佳实践推荐 (01) -- Node.js Best Practices">https://www.tanglijin.top/2023/02/best-practice-01/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Node-js/" rel="tag"><i class="fa fa-tag"></i> Node.js</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/02/recommend-algorithm-03/" rel="prev" title="算法和试题 (003) -- The Algorithms - JavaScript">
                  <i class="fa fa-chevron-left"></i> 算法和试题 (003) -- The Algorithms - JavaScript
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/best-practice-02/" rel="next" title="最佳实践推荐 (02) -- clean-code-javascript">
                  最佳实践推荐 (02) -- clean-code-javascript <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唐李锦</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.17.1/algoliasearch-lite.umd.js" integrity="sha256-F7emIId74fYoGrHzsnu3iClRHIbBMhMCbxDoA1cfMAY=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.1/instantsearch.production.min.js" integrity="sha256-lz9C+x8+6w2rh56x5TrH5iYmE4Js2FiJS5h0tuMz7hQ=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"ljtang2009/blog","issue_term":"pathname","theme":"preferred-color-scheme","label":"Utteranc"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
