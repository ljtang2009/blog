<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/downloads/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/downloads/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/downloads/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/downloads/images/favicon/favicon.svg" color="#222">
  <meta name="google-site-verification" content="_2OctYreBeDkfTRiEHaXwB0wYaMK6F84qG97fNjM4qc">
  <meta name="msvalidate.01" content="84BDF5B17B36630CC4297E351B2B0D64">
  <meta name="baidu-site-verification" content="code-kuUu52WEwj">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.tanglijin.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":"flat","show_result":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":{"utterances":{"order":-1},"changyan":{"text":"畅言","order":0},"livere":{"text":"来必力","order":1},"valine":{"order":2},"disqus":{"order":3},"disqusjs":{"order":4},"gitalk":{"order":5},"giscus":{"order":6}},"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"HWL3YK5R6C","apiKey":"17ce0bb5e5dc71bf5e3e37006cc05b55","indexName":"blog","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="解释单向数据流和双向数据绑定对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题 - 前端 - Vue">
<meta property="og:url" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/index.html">
<meta property="og:site_name" content="唐李锦的空间">
<meta property="og:description" content="解释单向数据流和双向数据绑定对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215110550866.png">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215110625108.png">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215110650930.png">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215110703001.png">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215104416987.png">
<meta property="og:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230216133653028.png">
<meta property="article:published_time" content="2023-08-03T06:00:00.000Z">
<meta property="article:modified_time" content="2023-08-03T09:52:16.980Z">
<meta property="article:author" content="唐李锦">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tanglijin.top/2023/08/interview-fontend-vue/image-20230215110550866.png">


<link rel="canonical" href="https://www.tanglijin.top/2023/08/interview-fontend-vue/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.tanglijin.top/2023/08/interview-fontend-vue/","path":"2023/08/interview-fontend-vue/","title":"面试题 - 前端 - Vue"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试题 - 前端 - Vue | 唐李锦的空间</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WSZ6XMJ0XL"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-WSZ6XMJ0XL","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?85df606204b9d08c7ff41bedceef09f7"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="唐李锦的空间" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">唐李锦的空间</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">69</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">74</span></a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">1.</span> <span class="nav-text">解释单向数据流和双向数据绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-defineProperty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">Object.defineProperty 有什么缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9-MVC%EF%BC%8CMVP%EF%BC%8CMVVM-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">对 MVC，MVP，MVVM 的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93-Vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9FProxy-%E4%B8%8E-Object-defineProperty-%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">你知道 Vue 响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Composition-API-%E7%9A%84%E5%87%BA%E7%8E%B0%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C%EF%BC%8C%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%AA%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">Composition API 的出现带来哪些新的开发体验，为啥需要这个？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-jQuery%EF%BC%8CVue-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">7.</span> <span class="nav-text">对比 jQuery，Vue 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%86%8D-Vue-%E7%9A%84%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E9%87%8C%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80-CSS%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">如何再 Vue 的单文件组件里的样式定义全局 CSS？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-root%EF%BC%8C-parent%EF%BC%8C-refs"><span class="nav-number">9.</span> <span class="nav-text">说一下$root，$parent，$refs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">Vue 中怎么自定义指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8-vue3-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="nav-number">11.</span> <span class="nav-text">Vue 中怎么自定义过滤器 (vue3 不支持)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">12.</span> <span class="nav-text">Vue 等单页面应用的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-router-%E4%BD%BF%E7%94%A8-params-%E4%B8%8E-query-%E4%BC%A0%E5%8F%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">Vue-router 使用 params 与 query 传参有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD-keep-alive-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">Vue 中 keep-alive 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">Vue 如何实现单页面应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%91-4-%E7%A7%8D-Vue-%E5%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E5%92%8C%E5%AE%83%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">说出至少 4 种 Vue 当中的指令和它的用法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%B8%B2%E6%9F%93%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">如何实现一个路径渲染多个组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E8%B7%AF%E5%BE%84%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">如何实现多个路径共享一个组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">19.</span> <span class="nav-text">如何监测动态路由的变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router-%E4%B8%AD%E7%9A%84-router-link-%E4%B8%8A-v-slot-%E5%B1%9E%E6%80%A7%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">vue-router 中的 router-link 上 v-slot 属性怎么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4-url-%E4%B8%AD%E7%9A%84"><span class="nav-number">21.</span> <span class="nav-text">Vue 如何去除 url 中的 #</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">$route 和 $router 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">23.</span> <span class="nav-text">Vue 路由守卫</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">Vue 路由实现的底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">25.</span> <span class="nav-text">路由懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E6%8F%92%E6%A7%BD%E5%90%97%EF%BC%9F%E7%94%A8%E7%9A%84%E6%98%AF%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E8%BF%98%E6%98%AF%E5%8C%BF%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="nav-number">26.</span> <span class="nav-text">用过插槽吗？用的是具名插槽还是匿名插槽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-loader-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="nav-number">27.</span> <span class="nav-text">Vue-loader 解释一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%92%8C-React-%E4%B8%AD-diff-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="nav-number">28.</span> <span class="nav-text">Vue 和 React 中 diff 算法区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD-create-%E5%92%8C-mount-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">Vue 中 create 和 mount 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#axios-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%8F%8F%E8%BF%B0%E4%BD%BF%E7%94%A8%E5%AE%83%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">30.</span> <span class="nav-text">axios 是什么？怎么使用？描述使用它实现登录功能的流程?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fwatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9Fwatch-%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">computed 和 watch 的区别？watch 实现原理？watch 有几种写法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-forceUpdate-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">32.</span> <span class="nav-text">Vue $forceUpdate 的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-for-key"><span class="nav-number">33.</span> <span class="nav-text">v-for key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE-key-%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8-index-%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">为什么要设置 key 值，可以用 index 吗？为什么不能？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B%E7%94%BB%E5%9B%BE"><span class="nav-number">35.</span> <span class="nav-text">diff 复杂度原理及具体过程画图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84-Data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E6%A0%B9%E7%BB%84%E4%BB%B6%E5%8D%B4%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%91%A2%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">Vue 组件中的 Data 为什么是函数，根组件却是对象呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">37.</span> <span class="nav-text">Vue 的组件通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-Vuex"><span class="nav-number">38.</span> <span class="nav-text">什么情况下使用 Vuex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-state-%E7%9A%84%E5%80%BC%E5%90%97%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">Vuex 可以直接修改 state 的值吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Vuex-%E7%9A%84-mutation-%E4%B8%8D%E8%83%BD%E5%81%9A%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">40.</span> <span class="nav-text">为什么 Vuex 的 mutation 不能做异步操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9-Vuex-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9FVuex-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="nav-number">41.</span> <span class="nav-text">怎么修改 Vuex 中的状态？Vuex 中有哪些方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">42.</span> <span class="nav-text">Vuex 的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vue-nextTick-%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">什么是 Vue.nextTick()？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick-%E7%9F%A5%E9%81%93%E5%90%97%E3%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%AE%8F%E4%BB%BB%E5%8A%A1%E8%BF%98%E6%98%AF%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="nav-number">44.</span> <span class="nav-text">nextTick 知道吗、实现的原理是什么？是宏任务还是微任务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-dom-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">虚拟 dom 为什么会提高性能？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-Vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">你做过哪些 Vue 的性能优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">47.</span> <span class="nav-text">Vue 的常用修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD-template-%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">48.</span> <span class="nav-text">Vue 中 template 的编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Vue3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">谈谈你对 Vue3.0 有什么了解？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94-vue2-x-%E5%BF%AB-1-2-2-%E5%80%8D%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2"><span class="nav-number">49.1.</span> <span class="nav-text">性能比 vue2.x 快 1.2~2 倍如何实现的呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-vue3-0-%E4%BD%93%E7%A7%AF%E6%AF%94-vue2-x-%E5%B0%8F"><span class="nav-number">49.2.</span> <span class="nav-text">为什么 vue3.0 体积比 vue2.x 小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-0-%E7%BB%84%E5%90%88-API"><span class="nav-number">50.</span> <span class="nav-text">vue3.0 组合 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-%E5%92%8C-reactive-%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="nav-number">51.</span> <span class="nav-text">ref 和 reactive 的简单理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex-%E5%92%8C-redux-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%85%B1%E5%90%8C%E6%80%9D%E6%83%B3"><span class="nav-number">52.</span> <span class="nav-text">Vuex 和 redux 有什么区别？他们的共同思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%8E-Vue-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">53.</span> <span class="nav-text">简单说一下 微信小程序 与 Vue 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AF-leader%EF%BC%8C%E5%81%9A%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE-Vue-%E5%92%8C-React-%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">如果你是 leader，做管理系统项目 Vue 和 React 怎么选择？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="唐李锦"
      src="/downloads/images/avatar.png">
  <p class="site-author-name" itemprop="name">唐李锦</p>
  <div class="site-description" itemprop="description">我的名字叫唐李锦，这是我的空间。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="/downloads/images/wechat.png" title="微信 → &#x2F;downloads&#x2F;images&#x2F;wechat.png" rel="noopener me"><i class="fa fa-comments fa-fw"></i>微信</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ljtang2009" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljtang2009" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ho_ho_gl@hotmail.com" title="E-Mail → mailto:ho_ho_gl@hotmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.tanglijin.top/2023/08/interview-fontend-vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/downloads/images/avatar.png">
      <meta itemprop="name" content="唐李锦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐李锦的空间">
      <meta itemprop="description" content="我的名字叫唐李锦，这是我的空间。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面试题 - 前端 - Vue | 唐李锦的空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题 - 前端 - Vue
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-03 14:00:00 / 修改时间：17:52:16" itemprop="dateCreated datePublished" datetime="2023-08-03T14:00:00+08:00">2023-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">面试题-前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="解释单向数据流和双向数据绑定"><a href="#解释单向数据流和双向数据绑定" class="headerlink" title="解释单向数据流和双向数据绑定"></a>解释单向数据流和双向数据绑定</h2><p>对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（Unidirectional data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。</p>
<span id="more"></span>

<blockquote>
<p>人话：父组件数据传到子组件，这个数据流是单向的。子组件通过事件机制把数据传给父组件，这个数据流也是单向的。这两个数据流没有关联。</p>
</blockquote>
<p>而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。</p>
<h2 id="Object-defineProperty-有什么缺点"><a href="#Object-defineProperty-有什么缺点" class="headerlink" title="Object.defineProperty 有什么缺点"></a>Object.defineProperty 有什么缺点</h2><ol>
<li>无法监听 es6 的 Set、Map 变化；</li>
<li>无法监听 Class 类型的数据；</li>
<li>属性的新加或者删除也无法监听；</li>
<li>数组元素的增加和删除也无法监听。</li>
</ol>
<h2 id="对-MVC，MVP，MVVM-的理解"><a href="#对-MVC，MVP，MVVM-的理解" class="headerlink" title="对 MVC，MVP，MVVM 的理解"></a>对 MVC，MVP，MVVM 的理解</h2><p><img src="/2023/08/interview-fontend-vue/image-20230215110550866.png" alt="MVC"></p>
<p><img src="/2023/08/interview-fontend-vue/image-20230215110625108.png" alt="MVP"></p>
<p><img src="/2023/08/interview-fontend-vue/image-20230215110650930.png" alt="MVVM"></p>
<p><img src="/2023/08/interview-fontend-vue/image-20230215110703001.png" alt="MVVM"></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2023/08/interview-fontend-vue/image-20230215104416987.png" alt="生命周期"></p>
<p>使用场景：</p>
<p>mounted：发送 AJAX 请求</p>
<p>beforeDestroy: 移除事件绑定</p>
<h2 id="你知道-Vue-响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？"><a href="#你知道-Vue-响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="你知道 Vue 响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？"></a>你知道 Vue 响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？</h2><p>响应式原理：</p>
<p>vue 的响应式实现主要是利用了 Object.defineProperty 的方法里面的 setter 与 getter 方法的观察者模式来实现。在组件初始化时会给每一个 data 属性注册 getter 和 setter，然后再 new 一个自己的 Watcher 对象，此时 watcher 会立即调用组件的 render 函数去生成虚拟 DOM。在调用 render 的时候，就会需要用到 data 的属性值，此时会触发 getter 函数，将当前的 Watcher 函数注册进 sub 里。当 data 属性发生改变之后，就会遍历 sub 里所有的 watcher 对象，通知它们去重新渲染组件。</p>
<p>proxy 的优势如下：</p>
<p>Proxy 可以直接监听对象而非属性，可以直接监听数组的变化；<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p>
<p>Object.defineProperty 的优势如下:</p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill(垫片)来弥补</p>
<h2 id="Composition-API-的出现带来哪些新的开发体验，为啥需要这个？"><a href="#Composition-API-的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="Composition API 的出现带来哪些新的开发体验，为啥需要这个？"></a>Composition API 的出现带来哪些新的开发体验，为啥需要这个？</h2><ol>
<li>在 Compostion API 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于 react 的 hook 写法。</li>
<li>更好的重用逻辑代码，在 Options API 中通过 MIxins 重用逻辑代码，容易发生命名冲突且关系不清。</li>
<li>解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在 mounted 中设置定时器，但需要在 destroyed 中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。</li>
</ol>
<h2 id="对比-jQuery，Vue-有什么不同"><a href="#对比-jQuery，Vue-有什么不同" class="headerlink" title="对比 jQuery，Vue 有什么不同"></a>对比 jQuery，Vue 有什么不同</h2><p>jQuery 专注视图层，通过直接操作 DOM 去实现页面的一些逻辑渲染；Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发。Í</p>
<h2 id="如何再-Vue-的单文件组件里的样式定义全局-CSS？"><a href="#如何再-Vue-的单文件组件里的样式定义全局-CSS？" class="headerlink" title="如何再 Vue 的单文件组件里的样式定义全局 CSS？"></a>如何再 Vue 的单文件组件里的样式定义全局 CSS？</h2><p>在 style 标签上不加上 scoped 的属性，默认为全局 css 样式。</p>
<h2 id="说一下-root，-parent，-refs"><a href="#说一下-root，-parent，-refs" class="headerlink" title="说一下$root，$parent，$refs"></a>说一下$root，$parent，$refs</h2><p>$root，和$parent 都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过 parent 访问得到的是它最近一级的父组件，通过 root 访问得到的是根父组件。通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。</p>
<h2 id="Vue-中怎么自定义指令"><a href="#Vue-中怎么自定义指令" class="headerlink" title="Vue 中怎么自定义指令"></a>Vue 中怎么自定义指令</h2><p>通过 directive 来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有 bind 和 update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color-swatch&#x27;</span>, <span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">  el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：Vue 指定目的是优雅地操作 DOM 元素。</p>
</blockquote>
<h2 id="Vue-中怎么自定义过滤器-vue3-不支持"><a href="#Vue-中怎么自定义过滤器-vue3-不支持" class="headerlink" title="Vue 中怎么自定义过滤器 (vue3 不支持)"></a>Vue 中怎么自定义过滤器 (vue3 不支持)</h2><p>通过 filter 来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return</span><br><span class="line">value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; Vue.filter(&#x27;capitalize&#x27;, function (value) &#123; if (!value) return &#x27;&#x27;</span><br><span class="line">value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Vue-等单页面应用的优缺点"><a href="#Vue-等单页面应用的优缺点" class="headerlink" title="Vue 等单页面应用的优缺点"></a>Vue 等单页面应用的优缺点</h2><p>优点:</p>
<ol>
<li>单页应用的内容的改变不需要重新加载整个页面，web 应用更具响应性和更令人着迷。</li>
<li>单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</li>
<li>单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。</li>
<li>良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端 API 通用化，即同一套后端程序代码，不用修改就可以用于 Web 界面、手机、平板等多种客户端。</li>
</ol>
<p>缺点:</p>
<ol>
<li>首次加载耗时比较多。</li>
<li>SEO 问题，不利于百度，360 等搜索引擎收录。</li>
<li>容易造成 Css 命名冲突。</li>
<li>前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。</li>
</ol>
<h2 id="Vue-router-使用-params-与-query-传参有什么区别"><a href="#Vue-router-使用-params-与-query-传参有什么区别" class="headerlink" title="Vue-router 使用 params 与 query 传参有什么区别"></a>Vue-router 使用 params 与 query 传参有什么区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法上</span></span><br><span class="line"><span class="number">1</span>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>和<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示上</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：params是路由的一部分,必须要有。query是拼接在url后面的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，并加上参数，让路由建立 url /users/eduardo</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">&#x27;eduardo&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，结果是 /register?plan=private</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 hash，结果是 /about#team</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#team&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Vue-中-keep-alive-的作用"><a href="#Vue-中-keep-alive-的作用" class="headerlink" title="Vue 中 keep-alive 的作用"></a>Vue 中 keep-alive 的作用</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用 keepalive 包裹组件，此时 mouted，created 等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived 和 deactived，这两个钩子函数只有被 keepalive 包裹后才会调用。</p>
<h2 id="Vue-如何实现单页面应用"><a href="#Vue-如何实现单页面应用" class="headerlink" title="Vue 如何实现单页面应用"></a>Vue 如何实现单页面应用</h2><p>通常的 url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给 window 注册 onhashchange 事件，当哈希值改变时通过 location.hash 就能获得相应的哈希值，然后就能跳到相应的页面。</p>
<p>1.hash 通过监听浏览器的 onhashchange()事件变化，查找对应的路由规则</p>
<p>2.history 原理： 利用 H5 的 history 中新增的两个 API pushState() 和 replaceState() 和一个事件 onpopstate 监听 URL 变化</p>
<h2 id="说出至少-4-种-Vue-当中的指令和它的用法？"><a href="#说出至少-4-种-Vue-当中的指令和它的用法？" class="headerlink" title="说出至少 4 种 Vue 当中的指令和它的用法？"></a>说出至少 4 种 Vue 当中的指令和它的用法？</h2><p>v-if(判断是否隐藏，用来判断元素是否创建)<br>v-show(元素的显示隐藏，类似 css 中的 display 的 block 和 hidden)<br>v-for(把数据遍历出来)<br>v-bind(绑定属性)<br>v-model(实现双向绑定)</p>
<h2 id="如何实现一个路径渲染多个组件？"><a href="#如何实现一个路径渲染多个组件？" class="headerlink" title="如何实现一个路径渲染多个组件？"></a>如何实现一个路径渲染多个组件？</h2><p>可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。通过设置 components 即可同时渲染多个组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view left-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;LeftSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view main-content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view right-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;RightSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, components: &#123; default: Home, //</span><br><span class="line">LeftSidebar: LeftSidebar 的缩写 LeftSidebar, // 它们与 `<span class="tag">&lt;<span class="name">router-view</span></span></span><br><span class="line"><span class="tag">  &gt;</span>` 上的 `name` 属性匹配 RightSidebar, &#125;, &#125;, ], &#125;)&lt;/router-view</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何实现多个路径共享一个组件？"><a href="#如何实现多个路径共享一个组件？" class="headerlink" title="如何实现多个路径共享一个组件？"></a>如何实现多个路径共享一个组件？</h2><p>只需将多个路径的 component 字段的值设置为同一个组件即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="如何监测动态路由的变化"><a href="#如何监测动态路由的变化" class="headerlink" title="如何监测动态路由的变化"></a>如何监测动态路由的变化</h2><p>可以通过 watch 方法来对$route 进行监听，或者通过导航守卫的钩子函数 beforeRouteUpdate 来监听它的变化。</p>
<h2 id="vue-router-中的-router-link-上-v-slot-属性怎么用？"><a href="#vue-router-中的-router-link-上-v-slot-属性怎么用？" class="headerlink" title="vue-router 中的 router-link 上 v-slot 属性怎么用？"></a>vue-router 中的 router-link 上 v-slot 属性怎么用？</h2><p>router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 API，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 NavLink 这样的自定义组件里。</p>
<p>有时我们可能想把激活的 class 应用到一个外部元素而不是 <code>&lt;a&gt;</code> 标签本身，这时你可以在一个 router-link 中包裹该元素并使用 v-slot 属性来创建链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/foo&quot;</span> <span class="attr">custom</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; href, route, navigate, isActive, isExactActive &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive &amp;&amp; &#x27;router-link-active&#x27;, isExactActive &amp;&amp; &#x27;router-link-exact-active&#x27;]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span>&#123;&#123; route.fullPath &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-如何去除-url-中的"><a href="#Vue-如何去除-url-中的" class="headerlink" title="Vue 如何去除 url 中的 #"></a>Vue 如何去除 url 中的 <code>#</code></h2><p>将路由模式改为 history</p>
<p>由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <a target="_blank" rel="noopener" href="https://example.com/user/id%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA">https://example.com/user/id，就会得到一个</a> 404 错误。这就尴尬了。</p>
<p>不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> history = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line">  <span class="title function_">history</span>(&#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;/index.html&#x27;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">); <span class="comment">//注意放在所有的接口后面</span></span><br></pre></td></tr></table></figure>

<h2 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h2><p>$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。而$router 主要是用来操作路由的，它是 VueRouter 的实例，包含了一些路由的跳转方法 push，go, replace，钩子函数等</p>
<h2 id="Vue-路由守卫"><a href="#Vue-路由守卫" class="headerlink" title="Vue 路由守卫"></a>Vue 路由守卫</h2><p>vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的, 单个路由独享的, 或者组件级的。导航钩子有 3 个参数：</p>
<ol>
<li>to:即将要进入的目标路由对象；</li>
<li>from:当前导航即将要离开的路由对象；</li>
<li>next ：调用该方法后，才能进入下一个钩子函数（afterEach）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 检查用户是否已登录</span></span><br><span class="line">    !isAuthenticated &amp;&amp;</span><br><span class="line">    <span class="comment">// ❗️ 避免无限重定向</span></span><br><span class="line">    to.<span class="property">name</span> !== <span class="string">&#x27;Login&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 将用户重定向到登录页面</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Vue-路由实现的底层原理"><a href="#Vue-路由实现的底层原理" class="headerlink" title="Vue 路由实现的底层原理"></a>Vue 路由实现的底层原理</h2><p>在 Vue 中利用数据劫持 defineProperty 在原型 prototype 上初始化了一些 getter,分别是 router 代表当前 Router 的实例 、 route 代表当前 Router 的信息。在 install 中也全局注册了 router-view,router-link,其中的 Vue.util.defineReactive, 这是 Vue 里面观察者劫持数据的方法，劫持_route，当_route 触发 setter 方法的时候，则会通知到依赖的组件。</p>
<p>接下来在 init 中，会挂载判断是路由的模式，是 history 或者是 hash,点击行为按钮，调用 hashchange 或者 popstate 的同时更_route,_route 的更新会触发 route-view 的重新渲染。</p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>Vue Router 支持开箱即用的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports">动态导入</a>，这意味着你可以用动态导入代替静态导入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from &#x27;./views/UserDetails.vue&#x27;</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/UserDetails.vue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserDetails</span> &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="用过插槽吗？用的是具名插槽还是匿名插槽"></a>用过插槽吗？用的是具名插槽还是匿名插槽</h2><p>用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。</p>
<p>举例来说，这里有一个 <code>&lt;FancyButton&gt;</code> 组件，可以像这样使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FancyButton</span>&gt;</span></span><br><span class="line">  Click me!</span><br><span class="line">  <span class="comment">&lt;!-- 插槽内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FancyButton</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而 <FancyButton> 的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插槽出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-loader-解释一下"><a href="#Vue-loader-解释一下" class="headerlink" title="Vue-loader 解释一下"></a>Vue-loader 解释一下</h2><p>解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</p>
<h2 id="Vue-和-React-中-diff-算法区别"><a href="#Vue-和-React-中-diff-算法区别" class="headerlink" title="Vue 和 React 中 diff 算法区别"></a>Vue 和 React 中 diff 算法区别</h2><p>vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较。vue diff 时调动 patch 函数，参数是 vnode 和 oldVnode，分别代表新旧节点。</p>
<ol>
<li><p>vue 对比节点。当节点元素相同，但是 classname 不同，认为是不同类型的元素，删除重建，而 react 认为是同类型节点，只是修改节点属性。</p>
</li>
<li><p>vue 的列表对比，采用的是两端到中间比对的方式，而 react 采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移到第一个。总体上，vue 的方式比较高效。</p>
</li>
</ol>
<h2 id="Vue-中-create-和-mount-的区别"><a href="#Vue-中-create-和-mount-的区别" class="headerlink" title="Vue 中 create 和 mount 的区别"></a>Vue 中 create 和 mount 的区别</h2><p>create 为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。然而，挂载阶段还没开始，此时还未生成真实的 DOM，也就无法获取和操作 DOM 元素。而 mount 主要完成从虚拟 DOM 到真实 DOM 的转换挂载，此时 html 已经渲染出来了，所以可以直接操作 dom 节点。</p>
<h2 id="axios-是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#axios-是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="axios 是什么？怎么使用？描述使用它实现登录功能的流程?"></a>axios 是什么？怎么使用？描述使用它实现登录功能的流程?</h2><p>axios 是请求后台资源的模块。 通过 npm install axios -S 来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入 token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config&#x2F;index.js 进行代理配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a request interceptor</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something before request is sent</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with request error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a response interceptor</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// Any status code that lie within the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response data</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="computed-和-watch-的区别？watch-实现原理？watch-有几种写法？"><a href="#computed-和-watch-的区别？watch-实现原理？watch-有几种写法？" class="headerlink" title="computed 和 watch 的区别？watch 实现原理？watch 有几种写法？"></a>computed 和 watch 的区别？watch 实现原理？watch 有几种写法？</h2><p>计算属性 computed :</p>
<ol>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li>
<li>不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed</li>
<li>如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 一个计算属性的 getter</span></span><br><span class="line">  <span class="title function_">publishedBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// `this` 指向当前组件实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">author</span>.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>侦听属性 watch：</p>
<ol>
<li>不支持缓存，数据变，直接会触发相应的操作；</li>
<li>watch 支持异步；</li>
<li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li>
<li>当一个属性发生变化时，需要执行对应的操作；一对多；</li>
<li>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，<br>immediate：组件加载立即触发回调函数执行，<br>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="comment">// 每当 question 改变时，这个函数就会执行</span></span><br><span class="line">  <span class="title function_">question</span>(<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newQuestion.<span class="title function_">includes</span>(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getAnswer</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">someObject</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意：在嵌套的变更中，</span></span><br><span class="line">      <span class="comment">// 只要没有替换对象本身，</span></span><br><span class="line">      <span class="comment">// 那么这里的 `newValue` 和 `oldValue` 相同</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景举例：</p>
<ol>
<li>在计算购物车总金额的时候，可以用 computed。它支持缓存，页面上显示的各处总金额都只需要计算一次。</li>
<li>在有回调函数主要处理的时候，可以用 watch。它支持异步。</li>
</ol>
<h2 id="Vue-forceUpdate-的原理"><a href="#Vue-forceUpdate-的原理" class="headerlink" title="Vue $forceUpdate 的原理"></a>Vue $forceUpdate 的原理</h2><p>作用：</p>
<p>迫使 <code>Vue</code> 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<p>内部原理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$forceUpdate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_watcher</span>) &#123;</span><br><span class="line">    vm.<span class="property">_watcher</span>.<span class="title function_">update</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实例需要重新渲染是在依赖发生变化的时候会通知 watcher，然后通知 watcher 来调用 update 方法，就是这么简单。</p>
<h2 id="v-for-key"><a href="#v-for-key" class="headerlink" title="v-for key"></a>v-for key</h2><ul>
<li>key 是为 Vue 中的 vnode(虚拟 DOM) 标记的唯一 id,通过这个 key,我们的 diff 操作可以更准确、更快速</li>
<li>diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,然后超出差异.</li>
</ul>
<p>diff 程可以概括为：oldCh 和 newCh 各有两个头尾的变量 StartIdx 和 EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了 key，就会用 key 进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx&gt;EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.<br>准确: 如果不加 key,那么 vue 会选择复用节点(Vue 的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的 bug. 快速: key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code></p>
<blockquote>
<p>人话：在虚拟 DOM 构建成真实 DOM 时，Vue 会根据虚拟 DOM 的 key 判断，该 DOM 是否需要整个重新构建。如果 key 没变，则不整个重新构建，提高效率。</p>
</blockquote>
<h2 id="为什么要设置-key-值，可以用-index-吗？为什么不能？"><a href="#为什么要设置-key-值，可以用-index-吗？为什么不能？" class="headerlink" title="为什么要设置 key 值，可以用 index 吗？为什么不能？"></a>为什么要设置 key 值，可以用 index 吗？为什么不能？</h2><p>vue 中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是 item 里面 id index 等，因为 vue 组件高度复用增加 Key 可以标识组件的唯一性，为了更好地区别各个组件 key 的作用主要是为了高效的更新虚拟 DOM</p>
<h2 id="diff-复杂度原理及具体过程画图"><a href="#diff-复杂度原理及具体过程画图" class="headerlink" title="diff 复杂度原理及具体过程画图"></a>diff 复杂度原理及具体过程画图</h2><p>diff 算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p>
<p><img src="/2023/08/interview-fontend-vue/image-20230216133653028.png" alt="diff过程"></p>
<blockquote>
<p>人话：先比较新老虚拟 DOM 是否是同一类组件。如果不是，则整个老组件移除，构建新组件；如果是则继续比较新老虚拟 DOM 的子组件。如果是同一类组件，但组件内容不一样，则更新组件内容。如果组件里有数组子组件，则会考虑增删改。</p>
</blockquote>
<p>diff 算法有两个比较显著的特点：</p>
<p>1、比较只会在同层级进行, 不会跨层级比较。</p>
<p>2、在 diff 比较的过程中，循环从两边向中间收拢。</p>
<p>diff 流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引。</p>
<p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while 循环中会遇到四种情况：</p>
<p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p>
<p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p>
<p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p>
<p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。</p>
<p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>情形一：如果在循环中，oldStartIdx 大于 oldEndIdx 了，那就表示 oldChildren 比 newChildren 先循环完毕，那么 newChildren 里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到 DOM 中</p>
<p>情形二：如果在循环中，newStartIdx 大于 newEndIdx 了，那就表示 newChildren 比 oldChildren 先循环完毕，那么 oldChildren 里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p>
<h2 id="Vue-组件中的-Data-为什么是函数，根组件却是对象呢？"><a href="#Vue-组件中的-Data-为什么是函数，根组件却是对象呢？" class="headerlink" title="Vue 组件中的 Data 为什么是函数，根组件却是对象呢？"></a>Vue 组件中的 Data 为什么是函数，根组件却是对象呢？</h2><p>综上可知，如果 data 是一个函数的话，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。</p>
<p>所以说 vue 组件的 data 必须是函数。这都是因为 js 的特性带来的，跟 vue 本身设计无关。</p>
<h2 id="Vue-的组件通信"><a href="#Vue-的组件通信" class="headerlink" title="Vue 的组件通信"></a>Vue 的组件通信</h2><p>1、props 和$emit</p>
<p>父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件</p>
<p>2、$attrs和$listeners</p>
<p>3、中央事件总线 bus</p>
<p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个 Vue 事件 bus 对象，然后通过 bus.$emit触发事件，bus.$on 监听触发的事件。</p>
<p>4、provide 和 inject</p>
<p>父组件中通过 provider 来提供变量，然后在子组件中通过 inject 来注入变量。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<p>5、v-model</p>
<p>父组件通过 v-model 传递值给子组件时，会自动传递一个 value 的 prop 属性，在子组件中通过 this.$emit(‘input’,val)自动修改 v-model 绑定的值</p>
<p>6、$parent和$children</p>
<p>7、boradcast 和 dispatch</p>
<p>8、vuex 处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex 的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h2 id="什么情况下使用-Vuex"><a href="#什么情况下使用-Vuex" class="headerlink" title="什么情况下使用 Vuex"></a>什么情况下使用 Vuex</h2><p>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用 Vuex 能更好地在组件外部管理状态。</p>
<h2 id="Vuex-可以直接修改-state-的值吗？"><a href="#Vuex-可以直接修改-state-的值吗？" class="headerlink" title="Vuex 可以直接修改 state 的值吗？"></a>Vuex 可以直接修改 state 的值吗？</h2><p>可以直接修改，但是极其不推荐，state 的修改必须在 mutation 来修改，否则无法被 devtool 所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游&#x2F;回滚之类的操作。</p>
<h2 id="为什么-Vuex-的-mutation-不能做异步操作"><a href="#为什么-Vuex-的-mutation-不能做异步操作" class="headerlink" title="为什么 Vuex 的 mutation 不能做异步操作"></a>为什么 Vuex 的 mutation 不能做异步操作</h2><p>Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，否则无法被 devtools 所监测。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<h2 id="怎么修改-Vuex-中的状态？Vuex-中有哪些方法"><a href="#怎么修改-Vuex-中的状态？Vuex-中有哪些方法" class="headerlink" title="怎么修改 Vuex 中的状态？Vuex 中有哪些方法"></a>怎么修改 Vuex 中的状态？Vuex 中有哪些方法</h2><ul>
<li>通过<strong>this.$store.state.属性</strong> 的方法来访问状态</li>
<li>通过<strong>this.$store.commit(‘mutation 中的方法’)</strong> 来修改状态</li>
</ul>
<h2 id="Vuex-的缺点"><a href="#Vuex-的缺点" class="headerlink" title="Vuex 的缺点"></a>Vuex 的缺点</h2><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的，并且 state 中的值会伴随着浏览器的刷新而初始化，无缓存。</p>
<h2 id="什么是-Vue-nextTick-？"><a href="#什么是-Vue-nextTick-？" class="headerlink" title="什么是 Vue.nextTick()？"></a>什么是 Vue.nextTick()？</h2><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM，意思是 等你 dom 加载完毕以后再去调用 nextTick()里面的数据内容。</p>
<h2 id="nextTick-知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#nextTick-知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="nextTick 知道吗、实现的原理是什么？是宏任务还是微任务？"></a>nextTick 知道吗、实现的原理是什么？是宏任务还是微任务？</h2><p>微任务</p>
<p>原理：nextTick 方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>作用： nextTick 用于下次 Dom 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick 用于下次 Dom 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick 用于下次 Dom 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick,则可以在回调中获取更新后的 DOM。</p>
<h2 id="虚拟-dom-为什么会提高性能？"><a href="#虚拟-dom-为什么会提高性能？" class="headerlink" title="虚拟 dom 为什么会提高性能？"></a>虚拟 dom 为什么会提高性能？</h2><p>虚拟 DOM 其实就是一个 JavaScript 对象。通过这个 JavaScript 对象来描述真实 DOM，真实 DOM 的操作，一般都会对某块元素的整体重新渲染，采用虚拟 DOM 的话，当数据变化的时候，只需要局部刷新变化的位置就好了 ,</p>
<p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p>
<p><strong>具体实现步骤如下</strong></p>
<ul>
<li>用 <code>JavaScript</code> 对象结构表示 <code>DOM</code> 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把 2 所记录的差异应用到步骤 1 所构建的真正的<code>DOM</code>树上，视图就更新</li>
</ul>
<h2 id="你做过哪些-Vue-的性能优化？"><a href="#你做过哪些-Vue-的性能优化？" class="headerlink" title="你做过哪些 Vue 的性能优化？"></a>你做过哪些 Vue 的性能优化？</h2><p>1、首屏加载优化</p>
<p>2、路由懒加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/home/index.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">isShowHead</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、开启服务器 Gzip</p>
<p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的<code>compression-webpack-plugin</code>进行压缩,然后在 vue.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> productionGzipExtensions = [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]......<span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">      <span class="attr">test</span>:     <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) +                 <span class="string">&#x27;)$&#x27;</span>),</span><br><span class="line">      <span class="attr">threshold</span>: <span class="number">10240</span>,</span><br><span class="line">      <span class="attr">minRatio</span>: <span class="number">0.8</span></span><br><span class="line">       &#125;</span><br><span class="line">)]....</span><br></pre></td></tr></table></figure>

<p>4、启动 CDN 加速</p>
<p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p>
<p>5、代码层面优化</p>
<ul>
<li><p>computed 和 watch 区分使用场景</p>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；<br>watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
</li>
<li><p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p>
</li>
<li><p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p>
</li>
</ul>
<p>6、Webpack 对图片进行压缩</p>
<p>7、避免内存泄漏</p>
<p>8、减少 ES6 转为 ES5 的冗余代码</p>
<h2 id="Vue-的常用修饰符"><a href="#Vue-的常用修饰符" class="headerlink" title="Vue 的常用修饰符"></a>Vue 的常用修饰符</h2><p><strong>一、v-model 修饰符</strong></p>
<p>1、.lazy：</p>
<p>输入框改变，这个数据就会改变，lazy 这个修饰符会在光标离开 input 框才会更新数据.</p>
<p>2、.trim：</p>
<p>输入框过滤首尾的空格.</p>
<p>3、.number：</p>
<p>先输入数字就会限制输入只能是数字，先字符串就相当于没有加 number，注意，不是输入框不能输入字符串，是这个数据是数字.</p>
<p><strong>二、事件修饰符</strong></p>
<p>4、.stop：</p>
<p>阻止事件冒泡，相当于调用了 event.stopPropagation()方法：</p>
<p>5、.prevent：</p>
<p>阻止默认行为，相当于调用了 event.preventDefault()方法，比如表单的提交、a 标签的跳转就是默认事件.</p>
<p>6、.self：</p>
<p>只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个 div 里面有个按钮，div 和按钮都有事件，我们点击按钮，div 绑定的方法也会触发，如果 div 的 click 加上 self，只有点击到 div 的时候才会触发，变相的算是阻止冒泡.</p>
<p>7、.once：</p>
<p>事件只能用一次，无论点击几次，执行一次之后都不会再执行</p>
<p>8、.capture：</p>
<p>事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡</p>
<p>9、.sync</p>
<p>对 prop 进行双向绑定</p>
<p>10、.keyCode：</p>
<p>监听按键的指令，具体可以查看 vue 的键码对应表</p>
<h2 id="Vue-中-template-的编译过程"><a href="#Vue-中-template-的编译过程" class="headerlink" title="Vue 中 template 的编译过程"></a>Vue 中 template 的编译过程</h2><p>vue template 模板编译的过程经过 parse()生成 ast(抽象语法树),optimize 对静态节点优化，generate()生成 render 字符串 之后调用 new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p>
<h2 id="谈谈你对-Vue3-0-有什么了解？"><a href="#谈谈你对-Vue3-0-有什么了解？" class="headerlink" title="谈谈你对 Vue3.0 有什么了解？"></a>谈谈你对 Vue3.0 有什么了解？</h2><p>特点：</p>
<ol>
<li>性能比 vue2.x 快 1.2~2 倍</li>
<li>支持 tree-shaking，按需编译，体积比 vue2.x 更小</li>
<li>支持组合 API</li>
<li>更好的支持 TS</li>
<li>更先进的组件</li>
</ol>
<h3 id="性能比-vue2-x-快-1-2-2-倍如何实现的呢"><a href="#性能比-vue2-x-快-1-2-2-倍如何实现的呢" class="headerlink" title="性能比 vue2.x 快 1.2~2 倍如何实现的呢"></a>性能比 vue2.x 快 1.2~2 倍如何实现的呢</h3><p>1.diff 算法更快</p>
<p>vue2.0 是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p>
<p>vue3.0 是在创建虚拟 dom 中，会根据 DOM 的的内容会不会发生内容变化，添加静态标记， 谁有 flag！比较谁。</p>
<p>2、静态提升</p>
<p>vue2 中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3 中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p>
<p>3、事件侦听缓存</p>
<p>默认情况下，onclick 为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可</p>
<p>在之前会添加静态标记 8 会把点击事件当做动态属性 会进行 diff 算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p>
<h3 id="为什么-vue3-0-体积比-vue2-x-小"><a href="#为什么-vue3-0-体积比-vue2-x-小" class="headerlink" title="为什么 vue3.0 体积比 vue2.x 小"></a>为什么 vue3.0 体积比 vue2.x 小</h3><p>在 vue3.0 中创建 vue 项目 除了 vue-cli，webpack 外还有 一种创建方法是 Vite Vite 是作者开发的一款有意取代 webpack 的工具，其实现原理是利用 ES6 的 import 会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去<br>webpack 冗长的打包时间</p>
<h2 id="vue3-0-组合-API"><a href="#vue3-0-组合-API" class="headerlink" title="vue3.0 组合 API"></a>vue3.0 组合 API</h2><p>说一说 vue3.0 的组合 API 跟之前 vue2.0 在完成业务逻辑上的区别：</p>
<p>在 vue2.0 中： 主要是往 data 和 method 里面添加内容，一个业务逻辑需要什么 data 和 method 就往里面添加，而组合 API 就是 有一个自己的方法，里面有自己专注的 data 和 method。</p>
<p>再说一下组合 API 的本质是什么： 首先 composition API（组合 API） 和 Option API（vue2.0 中的 data 和 method）可以共用 composition API（组合 API）本质就是把内容添加到 Option API 中进行使用。</p>
<h2 id="ref-和-reactive-的简单理解"><a href="#ref-和-reactive-的简单理解" class="headerlink" title="ref 和 reactive 的简单理解"></a>ref 和 reactive 的简单理解</h2><ol>
<li>ref 和 reactive 都是 vue3 的监听数据的方法，本质是 proxy</li>
<li>ref 基本类型复杂类型都可以监听(我们一般用 ref 监听基本类型)，reactive 只能监听对象（arr，json）</li>
<li>ref 底层还是 reactive，ref 是对 reactive 的二次包装， ref 定义的数据访问的时候要多一个.value</li>
</ol>
<h2 id="Vuex-和-redux-有什么区别？他们的共同思想"><a href="#Vuex-和-redux-有什么区别？他们的共同思想" class="headerlink" title="Vuex 和 redux 有什么区别？他们的共同思想"></a>Vuex 和 redux 有什么区别？他们的共同思想</h2><p>区别：</p>
<ul>
<li>Vuex 改进了 Redux 中的 Action 和 Reducer 函数，以 mutations 变化函数取代 Reducer，无需 switch，只需在对应的 mutation 函数里改变 state 值就可以</li>
<li>Vuex 由于 Vue 自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的 state 就可以</li>
<li>Vuex 数据流的顺序是:View 调用 store.commit 提交对应的请求到 Store 中对应的 mutation 函数 – store 改变(vue 检测到数据变化自动渲染)</li>
</ul>
<p>共同思想：</p>
<ul>
<li>单一的数据源</li>
<li>变化可以预测</li>
<li><code>本质上:</code>Redux 和 Vuex 都是对 MVVM 思想的服务，将数据从视图中抽离的一种方案</li>
<li><code>形式上:</code>Vuex 借鉴了 Redux，将 store 作为全局的数据中心，进行数据管理</li>
</ul>
<h2 id="简单说一下-微信小程序-与-Vue-的区别"><a href="#简单说一下-微信小程序-与-Vue-的区别" class="headerlink" title="简单说一下 微信小程序 与 Vue 的区别"></a>简单说一下 微信小程序 与 Vue 的区别</h2><p>1、生命周期：</p>
<p><code>小程序</code>的钩子函数要简单得多 。 <code>vue</code>的钩子函数在跳转新页面时，钩子函数都会触发，但是<code>小程序</code>的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p>
<p>在页面加载请求数据时，两者钩子的使用有些类似，<code>vue</code>一般会在<code>created</code>或者<code>mounted</code>中请求数据，而在<code>小程序</code>，会在<code>onLoad</code>或者<code>onShow</code>中请求数据。</p>
<p>2、数据绑定：</p>
<p>vue 动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;imgSrc&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=<span class="string">&quot;&#123;&#123;imgSrc&#125;&#125;&quot;</span>&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure>

<p>3、列表循环</p>
<p>4、显示与隐藏元素</p>
<p><code>vue</code>中，使用<code>v-if</code> 和<code>v-show</code>控制元素的显示和隐藏</p>
<p><code>小程序</code>中，使用<code>wx-if</code>和<code>hidden</code>控制元素的显示和隐藏</p>
<p>5、事件处理</p>
<p><code>vue</code>：使用<code>v-on:event</code>绑定事件，或者使用<code>@event</code>绑定事件</p>
<p><code>小程序</code>中，全用<code>bindtap(bind+event)</code>，或者<code>catchtap(catch+event)</code>绑定事件</p>
<p>6、数据的双向绑定</p>
<p>在<code>vue</code>中,只需要再<code>表单</code>元素上加上<code>v-model</code>,然后再绑定<code>data</code>中对应的一个值，当表单元素内容发生变化时，<code>data</code>中对应的值也会相应改变 。</p>
<p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过<code>this.setData(&#123;key:value&#125;)</code>来将表单上的值赋值给<code>data</code>中的对应值 。</p>
<p>7、绑定事件传参</p>
<p>在<code>vue</code>中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p>
<p>在<code>小程序</code>中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的<code>data-</code>属性上，然后在方法中，通过<code>e.currentTarget.dataset.*</code>的方式获取</p>
<p>8、父子组件通信</p>
<p>父组件向子组件传递数据，只需要在子组件通过<code>v-bind</code>传入一个值，在子组件中，通过<code>props</code>接收，即可完成数据的传递</p>
<p>父组件向子组件通信和<code>vue</code>类似，但是<code>小程序</code>没有通过<code>v-bind</code>，而是直接将值赋值给一个变量 在子组件<code>properties</code>中，接收传递的值</p>
<h2 id="如果你是-leader，做管理系统项目-Vue-和-React-怎么选择？"><a href="#如果你是-leader，做管理系统项目-Vue-和-React-怎么选择？" class="headerlink" title="如果你是 leader，做管理系统项目 Vue 和 React 怎么选择？"></a>如果你是 leader，做管理系统项目 Vue 和 React 怎么选择？</h2><p>评估项目成员的水平，如果成员 js 基础较好、编码能力较强则选择 React，否则 Vue。<br>评估系统的大小，如果想构建生态系统，则选择 React，如果要求而快，简单和“能用就行”,则选择 Vue。<br>评估系统运行环境，如果你想要一个同时适用于 Web 端和原生 APP 的框架，请选择 React(RN)。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/downloads/images/reward/wechatpay.png" alt="唐李锦 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/downloads/images/reward/alipay.png" alt="唐李锦 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>唐李锦
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.tanglijin.top/2023/08/interview-fontend-vue/" title="面试题 - 前端 - Vue">https://www.tanglijin.top/2023/08/interview-fontend-vue/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
              <a href="/tags/Vue/" rel="tag"><i class="fa fa-tag"></i> Vue</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/interview-fontend-nodejs/" rel="prev" title="面试题 - 前端 - NodeJS">
                  <i class="fa fa-chevron-left"></i> 面试题 - 前端 - NodeJS
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/interview-fontend-miniprogram/" rel="next" title="面试题 - 前端 - 微信小程序">
                  面试题 - 前端 - 微信小程序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唐李锦</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.17.1/algoliasearch-lite.umd.js" integrity="sha256-F7emIId74fYoGrHzsnu3iClRHIbBMhMCbxDoA1cfMAY=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.1/instantsearch.production.min.js" integrity="sha256-lz9C+x8+6w2rh56x5TrH5iYmE4Js2FiJS5h0tuMz7hQ=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"ljtang2009/blog","issue_term":"pathname","theme":"preferred-color-scheme","label":"Utteranc"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
